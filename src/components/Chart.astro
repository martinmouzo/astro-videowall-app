---
// Define las propiedades que acepta el componente
export interface Props {
  /** ID único de la gráfica de Axinstats */
  graphId: string;
  /** Tiempo de inicio para el rango de la gráfica (ej: 'end-30m', 'now-1h') */
  startTime?: string;
  /** Tiempo final para el rango de la gráfica (ej: 'now') */
  endTime?: string;
  /** Intervalo en milisegundos para actualizar la gráfica (0 para desactivar) */
  refreshInterval?: number;
  /** Ancho del contenedor del componente (CSS value) */
  width?: string;
  /** Altura del contenedor del componente (CSS value) */
  height?: string;
  /** URL de un logo para mostrar (opcional) */
  logoUrl?: string;
  /** Altura máxima del logo (CSS value) */
  logoHeight?: string;
  /** Texto a mostrar durante la carga */
  loadingText?: string;
  /** ID único para el componente (opcional, se genera automáticamente) */
  uniqueId?: string;
  /** Parámetros adicionales para la URL de Axinstats */
  extraParams?: Record<string, string>;
  /** Aspect ratio for the chart image itself, e.g., "1430 / 300" */
  imageAspectRatio?: string;
}

// Default aspect ratio if not provided, matching common Axinstats chart proportions
const DEFAULT_IMAGE_ASPECT_RATIO = "1430 / 300";

// Establece valores predeterminados para props opcionales
const {
  graphId,
  startTime = "end-30m",
  endTime = "now",
  refreshInterval = 240000,
  width = "100%",
  height = "100%",
  logoUrl = "",
  logoHeight = "0px",
  loadingText = "Cargando...",
  uniqueId = `axinstats-${Math.random().toString(36).substring(2, 11)}`,
  extraParams = {},
  imageAspectRatio = DEFAULT_IMAGE_ASPECT_RATIO,
} = Astro.props;

// IDs únicos para los elementos DOM
const containerId = `container-${uniqueId}`;
const imageId = `image-${uniqueId}`;
const imageBackId = `image-back-${uniqueId}`;
const loadingId = `loading-${uniqueId}`;
---

<div class="axinstats-chart-host" id={containerId} style={`width: ${width}; height: ${height};`}>
  {logoUrl && logoHeight !== "0px" && <img src={logoUrl} class="logo" alt="Logo" />}
  <!-- Imagen principal -->
  <img
    id={imageId}
    alt={`Axinstats Chart ${graphId}`}
    class="chart-image"
  />
  <!-- Imagen de respaldo para transiciones suaves -->
  <img
    id={imageBackId}
    alt={`Axinstats Chart ${graphId} Background`}
    class="chart-image-back"
  />
  <div id={loadingId} class="loading">
    <div class="loading-content">
      <div class="spinner"></div>
      <div>{loadingText}</div>
    </div>
  </div>
</div>

<script
  define:vars={{
    containerId,
    imageId,
    imageBackId,
    loadingId,
    graphId,
    startTime,
    endTime,
    refreshInterval,
    extraParams
  }}
>
  const containerElement = document.getElementById(containerId);
  const imageElement = document.getElementById(imageId);
  const imageBackElement = document.getElementById(imageBackId);
  const loadingElement = document.getElementById(loadingId);
  let intervalId = undefined;
  let retryTimeoutId = undefined;
  let isTransitioning = false;
  let currentImageIsBack = false;

  const updateImageUrl = () => {
    if (containerElement && imageElement && imageBackElement && loadingElement) {
      const actualWidth = Math.floor(containerElement.offsetWidth);
      const actualHeight = Math.floor(containerElement.offsetHeight);

      if (actualWidth === 0 || actualHeight === 0) {
        // If container has no dimensions yet, retry shortly.
        // This can happen during initial layout or if hidden.
        setTimeout(updateImageUrl, 100);
        return;
      }

      if (isTransitioning) {
        // Skip update if transition is in progress
        return;
      }

      const params = new URLSearchParams({
        Graph: graphId,
        Start: startTime,
        End: endTime,
        Width: "1400px",
        Height: "300px",
        Theme: "dark",
        _: new Date().getTime().toString()
      });

      for (const [key, value] of Object.entries(extraParams)) {
        params.append(key, value);
      }

      const newImageUrl = `/api/axinstats-proxy?${params.toString()}`;

      // Determine which image to load into (the one that's currently not visible)
      const targetImage = currentImageIsBack ? imageElement : imageBackElement;
      const visibleImage = currentImageIsBack ? imageBackElement : imageElement;

      // Show loading state only for the first load
      if (!visibleImage.src || visibleImage.style.opacity === "0") {
        loadingElement.style.display = "flex";
        loadingElement.innerHTML = `
          <div class="loading-content">
            <div class="spinner"></div>
            <div>Cargando gráfico...</div>
          </div>
        `;
      }

      targetImage.onload = () => {
        // Clear any pending retry timeout
        if (retryTimeoutId) {
          clearTimeout(retryTimeoutId);
          retryTimeoutId = undefined;
        }

        // Check if this is actually a placeholder image (error response)
        fetch(newImageUrl, { method: 'HEAD' })
          .then(response => {
            if (response.headers.get('X-Axinstats-Error')) {
              const errorType = response.headers.get('X-Axinstats-Error');
              const retryDelay = errorType === 'service-error' ? 30000 : 45000; // 30s for service errors, 45s for network errors

              console.warn(`Axinstats ${errorType} detected for ${graphId}, will retry in ${retryDelay/1000} seconds`);

              // Update loading message to show error state
              loadingElement.innerHTML = `
                <div class="loading-content error">
                  <div class="error-icon">⚠</div>
                  <div>Servicio temporalmente no disponible</div>
                  <div class="retry-info">Reintentando automáticamente...</div>
                </div>
              `;
              loadingElement.style.display = "flex";

              // Schedule a retry
              retryTimeoutId = setTimeout(updateImageUrl, retryDelay);
            } else {
              // Successful load - perform smooth transition
              performSmoothTransition(targetImage, visibleImage);
            }
          })
          .catch(() => {
            // If HEAD request fails, assume it's a valid image
            performSmoothTransition(targetImage, visibleImage);
          });
      };

      targetImage.onerror = () => {
        console.error(`Error loading chart ${graphId}`);

        // Show error state
        loadingElement.innerHTML = `
          <div class="loading-content error">
            <div class="error-icon">⚠</div>
            <div>Error al cargar gráfico</div>
            <div class="retry-info">Reintentando en 45 segundos...</div>
          </div>
        `;
        loadingElement.style.display = "flex";

        // Schedule a retry for network errors
        retryTimeoutId = setTimeout(updateImageUrl, 45000);
      };

      // Only update src if it's different to avoid unnecessary reloads
      if (targetImage.src !== newImageUrl) {
        targetImage.src = newImageUrl;
      }
    } else {
      console.error("AxinstatsChart: Elementos DOM no encontrados.");
    }
  };

  const performSmoothTransition = (newImage, oldImage) => {
    if (isTransitioning) return;

    isTransitioning = true;
    loadingElement.style.display = "none";

    // If this is the first image load
    if (oldImage.style.opacity === "0" && newImage.style.opacity === "0") {
      newImage.style.opacity = "1";
      currentImageIsBack = !currentImageIsBack;
      isTransitioning = false;
      return;
    }

    // Prepare the new image for transition
    newImage.style.opacity = "0";
    newImage.style.display = "block";

    // Force reflow to ensure styles are applied
    newImage.offsetHeight;

    // Start the fade transition
    requestAnimationFrame(() => {
      newImage.style.transition = "opacity 0.8s ease-in-out";
      oldImage.style.transition = "opacity 0.8s ease-in-out";

      newImage.style.opacity = "1";
      oldImage.style.opacity = "0";

      // Complete the transition after animation
      setTimeout(() => {
        oldImage.style.display = "none";
        oldImage.style.transition = "";
        newImage.style.transition = "";
        currentImageIsBack = !currentImageIsBack;
        isTransitioning = false;
      }, 850); // Slightly longer than transition duration for safety
    });
  };

  let resizeObserver;

  function initialize() {
    updateImageUrl();

    if (refreshInterval > 0) {
      intervalId = window.setInterval(updateImageUrl, refreshInterval);
    }

    if (containerElement) {
      resizeObserver = new ResizeObserver(() => {
        // When the container size changes, update the image URL
        // to fetch a new image with the new dimensions.
        updateImageUrl();
      });
      resizeObserver.observe(containerElement);
    }
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initialize);
  } else {
    initialize();
  }

  const cleanup = () => {
    if (intervalId) {
      clearInterval(intervalId);
      intervalId = undefined;
    }
    if (retryTimeoutId) {
      clearTimeout(retryTimeoutId);
      retryTimeoutId = undefined;
    }
    if (resizeObserver && containerElement) {
      resizeObserver.unobserve(containerElement);
    }
    if (imageElement) {
      imageElement.src = ""; // Clear src to stop loading
    }
    if (imageBackElement) {
      imageBackElement.src = ""; // Clear src to stop loading
    }
  };

  window.addEventListener("beforeunload", cleanup);
  document.addEventListener("astro:before-swap", cleanup);
</script>

<style define:vars={{ logoHeight, imageAspectRatio }}>
  .axinstats-chart-host {
    position: relative;
    overflow: hidden;
    box-sizing: border-box;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .chart-image,
  .chart-image-back {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    max-width: 100%;
    max-height: 100%;
    width: 100%;
    height: 100%;
    object-fit: contain;
    margin: auto;
    border: none;
    padding: 0;
    background-color: transparent;
    opacity: 0;
    transition: opacity 0.8s ease-in-out;
    aspect-ratio: var(--imageAspectRatio);
    /* Optimizaciones para transiciones suaves */
    transform: translateZ(0);
    backface-visibility: hidden;
    will-change: opacity;
  }

  .loading {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: #ccc;
    background-color: rgba(30, 30, 30, 0.9);
    font-size: 0.9em;
    font-family: 'Roboto Mono Variable', 'Roboto Mono', monospace;
    font-weight: 400;
    z-index: 2;
    text-align: center;
    padding: 20px;
    box-sizing: border-box;
  }

  .loading-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
  }

  .loading-content.error {
    color: #ffaa00;
    font-family: 'Roboto Mono Variable', 'Roboto Mono', monospace;
    font-weight: 500;
  }

  .spinner {
    width: 20px;
    height: 20px;
    border: 2px solid transparent;
    border-top: 2px solid #ccc;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  .error-icon {
    font-size: 24px;
    color: #ffaa00;
  }

  .retry-info {
    font-size: 0.8em;
    color: #888;
    margin-top: 8px;
    font-family: 'Roboto Mono Variable', 'Roboto Mono', monospace;
    font-weight: 300;
    letter-spacing: 0.5px;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  .logo {
    position: absolute;
    max-width: 90%;
    max-height: var(--logoHeight);
    object-fit: contain;
    z-index: 10;
    top: 8px;
    left: 8px;
  }
</style>
