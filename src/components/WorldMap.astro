---
// WorldMap.astro - Componente de mapa mundial con latency pins
import { latencyConfig } from '../mocks/data/latency-data';
---

<div id="world-map" class="world-map-container"></div>

<style>
  .world-map-container {
    width: 100%;
    height: 100vh;
    position: relative;
    background: #1E1E1E;
    overflow: hidden;
  }

  /* Ocultar controles de MapLibre */
  :global(.maplibregl-ctrl-group),
  :global(.maplibregl-ctrl-attrib),
  :global(.maplibregl-ctrl-logo),
  :global(.maplibregl-ctrl) {
    display: none !important;
  }

  /* Pin central de Arteixo - Static for videowall */
  :global(.pin-arteixo) {
    width: 120px;
    height: 50px;
    background: linear-gradient(135deg, #FFD700, #FFA500);
    border-radius: 25px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'Arial', sans-serif;
    font-weight: bold;
    color: #000;
    font-size: 16px;
    box-shadow: 0 6px 20px rgba(255, 215, 0, 0.4);
    z-index: 1000;
    border: 2px solid #fff;
    transform: translate(-50%, -50%);
    pointer-events: none;
    position: absolute;
  }

  /* Pins de latencia - Static for videowall */
  :global(.pin-latency) {
    width: 90px;
    height: 50px;
    background: linear-gradient(135deg, #2DB34A, #20A037);
    border-radius: 25px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'Arial', sans-serif;
    font-weight: bold;
    color: white;
    z-index: 900;
    transform: translate(-50%, -50%);
    box-shadow: 0 4px 15px rgba(45, 179, 74, 0.4);
    border: 2px solid rgba(255, 255, 255, 0.3);
    opacity: 0;
    animation: pinAppear 0.8s ease-out forwards;
    pointer-events: none;
    position: absolute;
  }

  :global(.pin-latency.good) {
    background: linear-gradient(135deg, #2DB34A, #20A037);
    box-shadow: 0 4px 15px rgba(45, 179, 74, 0.4);
  }

  :global(.pin-latency.warning) {
    background: linear-gradient(135deg, #FF9500, #E6840D);
    box-shadow: 0 4px 15px rgba(255, 149, 0, 0.4);
  }

  :global(.pin-latency.critical) {
    background: linear-gradient(135deg, #FF3B30, #D70015);
    box-shadow: 0 4px 15px rgba(255, 59, 48, 0.4);
  }

  :global(.pin-latency.offline) {
    background: linear-gradient(135deg, #8E8E93, #6D6D78);
    box-shadow: 0 4px 15px rgba(142, 142, 147, 0.4);
  }

  :global(.pin-value) {
    text-align: center;
    font-size: 18px;
    line-height: 1.2;
  }

  :global(.pin-unit) {
    font-size: 12px;
    opacity: 0.9;
    margin-left: 2px;
  }

  /* Labels de pa√≠ses */
  :global(.country-label) {
    position: absolute;
    font-family: 'Arial', sans-serif;
    font-weight: bold;
    font-size: 16px;
    color: white;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    transform: translate(-50%, -120%);
    z-index: 800;
    pointer-events: none;
    opacity: 0;
    animation: labelAppear 0.8s ease-out forwards;
    background: rgba(0, 0, 0, 0.6);
    padding: 4px 12px;
    border-radius: 15px;
    backdrop-filter: blur(10px);
    white-space: nowrap;
  }

  /* Animaciones */
  @keyframes pinAppear {
    0% {
      opacity: 0;
      transform: translate(-50%, -50%) scale(0.3) rotate(180deg);
    }
    60% {
      transform: translate(-50%, -50%) scale(1.1) rotate(-10deg);
    }
    100% {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1) rotate(0deg);
    }
  }

  @keyframes labelAppear {
    0% {
      opacity: 0;
      transform: translate(-50%, -120%) translateY(20px);
    }
    100% {
      opacity: 1;
      transform: translate(-50%, -120%) translateY(0);
    }
  }

  /* Pulsing effect autom√°tico para pins activos */
  @keyframes pulse {
    0%, 100% {
      box-shadow: 0 4px 15px rgba(45, 179, 74, 0.4), 0 0 0 0 rgba(45, 179, 74, 0.7);
    }
    50% {
      box-shadow: 0 4px 15px rgba(45, 179, 74, 0.4), 0 0 0 10px rgba(45, 179, 74, 0);
    }
  }

  /* Aplicar pulse autom√°tico a pins con buena latencia */
  :global(.pin-latency.good) {
    animation: pinAppear 0.8s ease-out forwards, pulse 3s ease-in-out infinite 2s;
  }

  /* L√≠neas de conexi√≥n SVG overlay */
  :global(.connection-lines) {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 500;
  }

  :global(.connection-line) {
    stroke: #2DB34A;
    stroke-width: 2;
    fill: none;
    opacity: 0.8;
    stroke-dasharray: 5,5;
    animation: dashMove 2s linear infinite;
  }

  @keyframes dashMove {
    0% { stroke-dashoffset: 0; }
    100% { stroke-dashoffset: 20; }
  }
</style>

<script>
  import maplibregl from 'maplibre-gl';
  import 'maplibre-gl/dist/maplibre-gl.css';
  import { latencyConfig } from '../mocks/data/latency-data';
  import type { LngLatLike, StyleSpecification, ExpressionSpecification } from 'maplibre-gl';

  let map: maplibregl.Map;
  let markers: maplibregl.Marker[] = [];

  // Configuraci√≥n del mapa para videowall est√°tico
  const mapConfig = {
    container: 'world-map',
    style: {
      version: 8,
      sources: {
        'countries': {
          type: 'vector',
          tiles: [
            'https://tiles.openmaptiles.org/data/v3/{z}/{x}/{y}.pbf?key=get_your_own_OpenmapTiles_key'
          ],
          minzoom: 0,
          maxzoom: 8
        },
        'countries-natural-earth': {
          type: 'vector',
          tiles: [
            'https://demotiles.maplibre.org/tiles/{z}/{x}/{y}.pbf'
          ],
          minzoom: 0,
          maxzoom: 8
        },
        'osm': {
          type: 'raster',
          tiles: [
            'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png',
            'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
            'https://c.tile.openstreetmap.org/{z}/{x}/{y}.png'
          ],
          tileSize: 256
        }
      },
      layers: [
        {
          id: 'background',
          type: 'background',
          paint: {
            'background-color': '#1E1E1E'
          }
        },
        {
          id: 'osm-base',
          type: 'raster',
          source: 'osm',
          paint: {
            'raster-opacity': 0.3,
            'raster-saturation': -0.8,
            'raster-contrast': 0.2
          }
        },
        {
          id: 'countries-base',
          type: 'fill',
          source: 'countries-natural-earth',
          'source-layer': 'countries',
          paint: {
            'fill-color': '#515151',
            'fill-opacity': 0.7
          }
        },
        {
          id: 'countries-stroke',
          type: 'line',
          source: 'countries-natural-earth',
          'source-layer': 'countries',
          paint: {
            'line-color': '#333333',
            'line-width': 0.5
          }
        }
      ]
    } as StyleSpecification,
    center: [0, 20] as LngLatLike, // Centro del mundo ligeramente al norte
    zoom: 2,
    pitch: 0,
    bearing: 0,
    // Desactivar toda interacci√≥n para videowall est√°tico
    interactive: false,
    scrollZoom: false,
    boxZoom: false,
    dragRotate: false,
    dragPan: false,
    keyboard: false,
    doubleClickZoom: false,
    touchZoomRotate: false,
    // Configuraciones adicionales para estabilidad
    preserveDrawingBuffer: true,
    antialias: true
  };

  function initializeMap() {
    try {
      map = new maplibregl.Map(mapConfig);

      map.on('load', () => {
        console.log('Mapa cargado - inicializando latency pins');

        // Notificaci√≥n de inicializaci√≥n exitosa (solo una vez)
        setTimeout(() => {
          if (typeof (window as any).notificationUtils !== 'undefined') {
            (window as any).notificationUtils.show(
              'success',
              'Monitor de Red Activo',
              'Sistema de monitoreo de latencia iniciado correctamente. Videowall en funcionamiento.',
              'üåç'
            );
          }
        }, 3000);

        // Colorear pa√≠ses espec√≠ficos
        addCountryColors();

        // Crear pins despu√©s de un breve delay
        setTimeout(() => {
          createArteixoPin();
          createLatencyPins();
          createConnectionLines();
        }, 500);

        // Iniciar actualizaciones de latencia
        startLatencyUpdates();
      });

      map.on('error', (e) => {
        console.error('Error en el mapa:', e);
        // Reintentar despu√©s de un delay si hay error
        setTimeout(() => {
          if (!map.loaded()) {
            initializeMap();
          }
        }, 2000);
      });

      return map;
    } catch (error) {
      console.error('Error inicializando el mapa:', error);
      // Reintentar despu√©s de un delay
      setTimeout(initializeMap, 2000);
    }
  }

  function addCountryColors() {
    // Crear expresi√≥n de mapbox para colorear pa√≠ses
    const expression: ExpressionSpecification = [
      'case',
      // Diferentes variantes de nombres para Estados Unidos
      ['==', ['get', 'NAME'], 'United States'], '#90BA3E',
      ['==', ['get', 'NAME'], 'United States of America'], '#90BA3E',
      ['==', ['get', 'NAME'], 'USA'], '#90BA3E',
      ['==', ['get', 'name'], 'United States'], '#90BA3E',
      ['==', ['get', 'name'], 'United States of America'], '#90BA3E',
      ['==', ['get', 'ADMIN'], 'United States of America'], '#90BA3E',
      ['==', ['get', 'NAME_EN'], 'United States'], '#90BA3E',
      ['==', ['get', 'iso_a2'], 'US'], '#90BA3E',
      // Brasil
      ['==', ['get', 'NAME'], 'Brazil'], '#90BA3E',
      ['==', ['get', 'NAME'], 'Brasil'], '#90BA3E',
      ['==', ['get', 'name'], 'Brazil'], '#90BA3E',
      ['==', ['get', 'iso_a2'], 'BR'], '#90BA3E',
      // Espa√±a
      ['==', ['get', 'NAME'], 'Spain'], '#FFD700',
      ['==', ['get', 'name'], 'Spain'], '#FFD700',
      ['==', ['get', 'iso_a2'], 'ES'], '#FFD700',
      // Sud√°frica
      ['==', ['get', 'NAME'], 'South Africa'], '#90BA3E',
      ['==', ['get', 'name'], 'South Africa'], '#90BA3E',
      ['==', ['get', 'iso_a2'], 'ZA'], '#90BA3E',
      // China
      ['==', ['get', 'NAME'], 'China'], '#90BA3E',
      ['==', ['get', 'name'], 'China'], '#90BA3E',
      ['==', ['get', 'iso_a2'], 'CN'], '#90BA3E',
      // Jap√≥n
      ['==', ['get', 'NAME'], 'Japan'], '#90BA3E',
      ['==', ['get', 'name'], 'Japan'], '#90BA3E',
      ['==', ['get', 'iso_a2'], 'JP'], '#90BA3E',
      // Australia
      ['==', ['get', 'NAME'], 'Australia'], '#90BA3E',
      ['==', ['get', 'name'], 'Australia'], '#90BA3E',
      ['==', ['get', 'iso_a2'], 'AU'], '#90BA3E',
      'transparent'
    ];

    // A√±adir capa para pa√≠ses coloreados usando ambas fuentes
    try {
      map.addLayer({
        id: 'countries-highlighted',
        type: 'fill',
        source: 'countries-natural-earth',
        'source-layer': 'countries',
        paint: {
          'fill-color': expression,
          'fill-opacity': 0.8
        }
      });
    } catch (error) {
      console.log('Error con countries-natural-earth, intentando con countries:', error);

      // Fallback a la fuente principal
      map.addLayer({
        id: 'countries-highlighted-fallback',
        type: 'fill',
        source: 'countries',
        'source-layer': 'countries',
        paint: {
          'fill-color': expression,
          'fill-opacity': 0.8
        }
      });
    }

    // Debug: Log para verificar las propiedades disponibles en ambas fuentes
    setTimeout(() => {
      console.log('=== DEBUGGING COUNTRY SOURCES ===');

      // Probar countries-natural-earth
      try {
        const features1 = map.querySourceFeatures('countries-natural-earth', {
          sourceLayer: 'countries'
        });
        console.log('Natural Earth features:', features1.length);
        features1.slice(0, 5).forEach((feature, index) => {
          console.log(`Natural Earth Feature ${index}:`, feature.properties);
        });
      } catch (e) {
        console.log('Error querying natural earth:', e);
      }

      // Probar countries
      try {
        const features2 = map.querySourceFeatures('countries', {
          sourceLayer: 'countries'
        });
        console.log('Countries features:', features2.length);
        features2.slice(0, 5).forEach((feature, index) => {
          console.log(`Countries Feature ${index}:`, feature.properties);
        });
      } catch (e) {
        console.log('Error querying countries:', e);
      }
    }, 3000);
  }

  function createArteixoPin() {
    const centralNode = latencyConfig.centralNode;
    console.log('Creando pin de Arteixo en coordenadas:', centralNode.coordinates);

    const arteixoPin = document.createElement('div');
    arteixoPin.className = 'pin-arteixo';
    arteixoPin.innerHTML = 'ARTEIXO';

    // Verificar que las coordenadas sean v√°lidas
    if (!centralNode.coordinates || centralNode.coordinates.length !== 2) {
      console.error('Coordenadas de Arteixo inv√°lidas:', centralNode.coordinates);
      return;
    }

    const marker = new maplibregl.Marker({
      element: arteixoPin,
      anchor: 'center'
    })
    .setLngLat(centralNode.coordinates)
    .addTo(map);

    markers.push(marker);
    console.log('Pin de Arteixo creado y agregado al mapa');

    // Verificar posici√≥n despu√©s de agregarlo
    setTimeout(() => {
      const lngLat = marker.getLngLat();
      const point = map.project(lngLat);
      console.log('Pin Arteixo - LngLat:', lngLat, 'Screen position:', point);
    }, 100);

    // Label para Espa√±a
    const arteixoLabel = document.createElement('div');
    arteixoLabel.className = 'country-label';
    arteixoLabel.innerHTML = 'ESPA√ëA';
    arteixoLabel.style.animationDelay = '0.5s';

    const labelMarker = new maplibregl.Marker({
      element: arteixoLabel,
      anchor: 'bottom'
    })
    .setLngLat(centralNode.coordinates)
    .addTo(map);

    markers.push(labelMarker);
  }

  function createLatencyPins() {
    console.log('Creando pins de latencia para nodos:', latencyConfig.remoteNodes.length);

    latencyConfig.remoteNodes.forEach((node, index) => {
      console.log(`Creando pin para ${node.country} en coordenadas:`, node.coordinates);

      // Verificar coordenadas v√°lidas
      if (!node.coordinates || node.coordinates.length !== 2) {
        console.error(`Coordenadas inv√°lidas para ${node.country}:`, node.coordinates);
        return;
      }

      // Pin de latencia
      const pin = document.createElement('div');
      pin.className = `pin-latency ${getLatencyStatus(node.latency)}`;
      pin.innerHTML = `
        <div class="pin-value">
          ${node.latency}<span class="pin-unit">ms</span>
        </div>
      `;

      pin.style.animationDelay = `${1.5 + (index * 0.3)}s`;

      const marker = new maplibregl.Marker({
        element: pin,
        anchor: 'center'
      })
      .setLngLat(node.coordinates)
      .addTo(map);

      markers.push(marker);
      console.log(`Pin para ${node.country} creado en:`, marker.getLngLat());

      // Verificar posici√≥n del pin despu√©s de crearlo
      setTimeout(() => {
        const lngLat = marker.getLngLat();
        const point = map.project(lngLat);
        console.log(`Pin ${node.country} - LngLat:`, lngLat, 'Screen position:', point);

        // Verificar si el pin est√° en posici√≥n 0,0 (problema com√∫n)
        if (point.x === 0 && point.y === 0) {
          console.warn(`‚ö†Ô∏è Pin ${node.country} est√° en posici√≥n 0,0 - posible problema de proyecci√≥n`);
        }
      }, 200);

      // Label del pa√≠s
      const label = document.createElement('div');
      label.className = 'country-label';
      label.innerHTML = node.country.toUpperCase();
      label.style.animationDelay = `${1.2 + (index * 0.3)}s`;

      const labelMarker = new maplibregl.Marker({
        element: label,
        anchor: 'bottom'
      })
      .setLngLat(node.coordinates)
      .addTo(map);

      markers.push(labelMarker);
    });

    console.log(`Total de marcadores creados: ${markers.length}`);
  }

  function createConnectionLines() {
    // Crear datos GeoJSON para las l√≠neas de conexi√≥n
    const features = latencyConfig.remoteNodes.map(node => ({
      type: 'Feature' as const,
      properties: {
        latency: node.latency,
        status: node.status,
        country: node.country
      },
      geometry: {
        type: 'LineString' as const,
        coordinates: [latencyConfig.centralNode.coordinates, node.coordinates]
      }
    }));

    // A√±adir fuente de datos para las l√≠neas
    map.addSource('connections', {
      type: 'geojson',
      data: {
        type: 'FeatureCollection',
        features: features
      }
    });

    // A√±adir capa de l√≠neas con colores din√°micos basados en latencia
    map.addLayer({
      id: 'connection-lines',
      type: 'line',
      source: 'connections',
      layout: {
        'line-join': 'round',
        'line-cap': 'round'
      },
      paint: {
        'line-color': [
          'case',
          ['<', ['get', 'latency'], 50], '#2DB34A',      // Verde para latencia baja
          ['<', ['get', 'latency'], 100], '#FF9500',     // Naranja para latencia media
          ['<', ['get', 'latency'], 200], '#FF3B30',     // Rojo para latencia alta
          '#8E8E93'                                       // Gris para offline
        ] as ExpressionSpecification,
        'line-width': [
          'case',
          ['<', ['get', 'latency'], 50], 3,               // L√≠neas m√°s gruesas para conexiones buenas
          ['<', ['get', 'latency'], 100], 2.5,
          ['<', ['get', 'latency'], 200], 2,
          1.5
        ] as ExpressionSpecification,
        'line-opacity': 0.8
      }
    });

    // A√±adir una segunda capa con efecto de animaci√≥n
    map.addLayer({
      id: 'connection-lines-animated',
      type: 'line',
      source: 'connections',
      layout: {
        'line-join': 'round',
        'line-cap': 'round'
      },
      paint: {
        'line-color': [
          'case',
          ['<', ['get', 'latency'], 50], '#2DB34A',
          ['<', ['get', 'latency'], 100], '#FF9500',
          ['<', ['get', 'latency'], 200], '#FF3B30',
          '#8E8E93'
        ] as ExpressionSpecification,
        'line-width': 1,
        'line-opacity': 0.6,
        'line-dasharray': [2, 4]
      }
    });
  }

  function getLatencyStatus(latency: number): string {
    if (latency < 50) return 'good';
    if (latency < 100) return 'warning';
    if (latency < 200) return 'critical';
    return 'offline';
  }

  function startLatencyUpdates() {
    setInterval(() => {
      const pins = document.querySelectorAll('.pin-latency');
      const updatedFeatures: any[] = [];

      pins.forEach((pin, index) => {
        const node = latencyConfig.remoteNodes[index];
        if (node) {
          const previousLatency = node.latency;
          const previousStatus = getLatencyStatus(previousLatency);

          // Simular variaci√≥n de latencia
          const variation = Math.floor(Math.random() * 60) - 30; // ¬±30ms
          const newLatency = Math.max(10, Math.min(500, node.latency + variation));
          const newStatus = getLatencyStatus(newLatency);

          // Detectar cambios cr√≠ticos para notificaciones (solo cambios importantes)
          const latencyChange = Math.abs(newLatency - previousLatency);
          const statusChanged = previousStatus !== newStatus;

          // Enviar notificaci√≥n solo para cambios cr√≠ticos o de estado
          if (statusChanged && (newStatus === 'critical' || newStatus === 'offline' || (previousStatus === 'critical' && newStatus === 'good'))) {
            sendLatencyNotification(node.country, previousLatency, newLatency, previousStatus, newStatus);
          }

          // Actualizar display
          const valueElement = pin.querySelector('.pin-value');
          if (valueElement) {
            valueElement.innerHTML = `${newLatency}<span class="pin-unit">ms</span>`;
          }

          // Actualizar clase de estado
          pin.className = `pin-latency ${newStatus}`;

          // Actualizar latencia en configuraci√≥n
          node.latency = newLatency;

          // Preparar datos actualizados para las l√≠neas
          updatedFeatures.push({
            type: 'Feature' as const,
            properties: {
              latency: newLatency,
              status: newStatus,
              country: node.country
            },
            geometry: {
              type: 'LineString' as const,
              coordinates: [latencyConfig.centralNode.coordinates, node.coordinates]
            }
          });
        }
      });

      // Actualizar las l√≠neas de conexi√≥n con los nuevos datos
      if (map && map.getSource('connections')) {
        (map.getSource('connections') as maplibregl.GeoJSONSource).setData({
          type: 'FeatureCollection',
          features: updatedFeatures
        });
      }
    }, 15000); // Actualizar cada 15 segundos para videowall

    // Notificaci√≥n peri√≥dica de estado general cada 5 minutos
    setInterval(() => {
      sendPeriodicStatsNotification();
    }, 300000); // 5 minutos
  }

  // Funci√≥n para enviar notificaciones cr√≠ticas de latencia (solo cambios importantes)
  function sendLatencyNotification(country: string, oldLatency: number, newLatency: number, oldStatus: string, newStatus: string) {
    if (typeof (window as any).notificationUtils === 'undefined') {
      return;
    }

    let type: 'success' | 'warning' | 'error' | 'info' = 'info';
    let title = '';
    let message = '';
    let icon = '';

    // Solo notificar cambios cr√≠ticos
    if (newStatus === 'critical' || newStatus === 'offline') {
      type = 'error';
      icon = 'üö®';
      title = 'Conexi√≥n Cr√≠tica';
      message = `${country}: Latencia cr√≠tica de ${newLatency}ms - Requiere atenci√≥n`;
    } else if (oldStatus === 'critical' && newStatus === 'good') {
      type = 'success';
      icon = '‚úÖ';
      title = 'Conexi√≥n Restaurada';
      message = `${country}: Conexi√≥n restaurada - Latencia normalizada a ${newLatency}ms`;
    }

    if (message) {
      (window as any).notificationUtils.show(type, title, message, icon);
    }
  }

  // Funci√≥n para limpiar y reinicializar el mapa
  function resetMap() {
    if (map) {
      // Limpiar marcadores existentes
      markers.forEach(marker => marker.remove());
      markers = [];

      // Remover el mapa
      map.remove();
    }

    // Reinicializar
    initializeMap();
  }

  // Funci√≥n para obtener estad√≠sticas del mapa
  function getMapStats() {
    const activeNodes = latencyConfig.remoteNodes.filter(node => node.status !== 'offline');
    const criticalNodes = latencyConfig.remoteNodes.filter(node => getLatencyStatus(node.latency) === 'critical');
    const averageLatency = Math.round(
      latencyConfig.remoteNodes.reduce((sum, node) => sum + node.latency, 0) /
      latencyConfig.remoteNodes.length
    );

    return {
      totalNodes: latencyConfig.remoteNodes.length + 1, // +1 por Arteixo
      activeConnections: activeNodes.length,
      criticalConnections: criticalNodes.length,
      averageLatency: averageLatency,
      markersCount: markers.length,
      mapLoaded: map ? map.loaded() : false,
      healthStatus: criticalNodes.length === 0 ? 'healthy' : criticalNodes.length < 3 ? 'warning' : 'critical'
    };
  }

  // Funci√≥n para enviar notificaciones de estado general (cada 5 minutos)
  function sendPeriodicStatsNotification() {
    if (typeof (window as any).notificationUtils === 'undefined') {
      return;
    }

    const stats = getMapStats();

    // Solo notificar si hay conexiones cr√≠ticas o estado muy bueno
    if (stats.criticalConnections > 2) {
      (window as any).notificationUtils.show(
        'error',
        'Alerta de Red',
        `${stats.criticalConnections} conexiones cr√≠ticas detectadas. Revisar infraestructura.`,
        'üö®'
      );
    } else if (stats.criticalConnections === 0 && stats.averageLatency < 40) {
      (window as any).notificationUtils.show(
        'success',
        'Red √ìptima',
        `Todas las conexiones funcionan correctamente. Latencia promedio: ${stats.averageLatency}ms`,
        'üåü'
      );
    }
  }

  // Funci√≥n de debugging para verificar estado del mapa
  function debugMapState() {
    console.log('=== DEBUG MAP STATE ===');
    console.log('Map loaded:', map ? map.loaded() : 'Map not initialized');
    console.log('Map center:', map ? map.getCenter() : 'N/A');
    console.log('Map zoom:', map ? map.getZoom() : 'N/A');
    console.log('Map bounds:', map ? map.getBounds() : 'N/A');
    console.log('Total markers:', markers.length);
    console.log('Latency config nodes:', latencyConfig.remoteNodes.length);

    // Verificar cada marcador individualmente
    markers.forEach((marker, index) => {
      const lngLat = marker.getLngLat();
      const screenPos = map.project(lngLat);
      console.log(`Marker ${index}:`, {
        lngLat: lngLat,
        screenPosition: screenPos,
        element: marker.getElement().className
      });
    });

    // Verificar si hay elementos DOM creados
    const pinElements = document.querySelectorAll('.pin-latency, .pin-arteixo');
    console.log('Pin elements in DOM:', pinElements.length);

    pinElements.forEach((pin, index) => {
      const rect = pin.getBoundingClientRect();
      console.log(`Pin ${index} DOM position:`, {
        top: rect.top,
        left: rect.left,
        width: rect.width,
        height: rect.height,
        className: pin.className,
        isVisible: rect.width > 0 && rect.height > 0
      });
    });

    // Verificar proyecci√≥n espec√≠fica de coordenadas conocidas
    console.log('=== PROJECTION TEST ===');
    const testCoords = [
      { name: 'Arteixo', coords: [-8.5096, 43.3039] },
      { name: 'New York', coords: [-74.0060, 40.7128] },
      { name: 'London', coords: [-0.1276, 51.5074] },
      { name: 'Tokyo', coords: [139.6917, 35.6895] }
    ];

    testCoords.forEach(test => {
      const projected = map.project(test.coords);
      console.log(`${test.name} (${test.coords}) -> Screen: (${projected.x}, ${projected.y})`);
    });
  }

  // Inicializar cuando el DOM est√© listo
  document.addEventListener('DOMContentLoaded', initializeMap);

  // Agregar debugging adicional despu√©s de que el mapa est√© cargado
  setTimeout(() => {
    if (map && map.loaded()) {
      debugMapState();

      // Verificar features de pa√≠ses para debugging
      console.log('=== DEBUGGING COUNTRY FEATURES ===');
      const features = map.querySourceFeatures('countries', {
        sourceLayer: 'countries'
      });

      // Buscar espec√≠ficamente Estados Unidos
      const usFeatures = features.filter(f =>
        f.properties && (
          f.properties.NAME === 'United States' ||
          f.properties.NAME === 'United States of America' ||
          f.properties.name === 'United States' ||
          f.properties.ADMIN === 'United States of America'
        )
      );

      console.log('US Features found:', usFeatures.length);
      usFeatures.forEach((feature, index) => {
        console.log(`US Feature ${index}:`, feature.properties);
      });

      // Log primeras 10 features para ver estructura
      features.slice(0, 10).forEach((feature, index) => {
        console.log(`Feature ${index}:`, feature.properties);
      });
    }
  }, 5000);

  // Funciones globales para debugging
  (window as any).mapUtils = {
    getLatencyConfig: () => latencyConfig,
    getMap: () => map,
    getMapStats: getMapStats,
    resetMap: resetMap,
    markers: () => markers,
    debugMapState: debugMapState
  };
</script>
