---
interface Props {
  region: string;
  indicadores: any[];
}

const { region, indicadores } = Astro.props;

// Mapeo de regiones del nombre de archivo al ID usado en los datos
const regionMapping: Record<string, string> = {
  'america': 'AMERICA',
  'europe': 'EUROPA',
  'asia': 'ASIA'
};

// Valores mock realistas por tipo y región
const mockValues: Record<number, Record<string, number>> = {
  3: { 'AMERICA': 779, 'EUROPA': 4323, 'ASIA': 483 }, // Tiendas abiertas
  13: { 'AMERICA': 12, 'EUROPA': 45, 'ASIA': 8 }, // Tiendas con cierre
  6: { 'AMERICA': 234, 'EUROPA': 578, 'ASIA': 156 }, // Incidencias
  4: { 'AMERICA': 5, 'EUROPA': 4, 'ASIA': 1 }, // Tiendas offline
  12: { 'AMERICA': 18, 'EUROPA': 43, 'ASIA': 12 }, // Reformas
  5: { 'AMERICA': 0, 'EUROPA': 0, 'ASIA': 0 }, // Contenidos pendientes
  1: { 'AMERICA': 1245, 'EUROPA': 3567, 'ASIA': 892 }, // Tickets acumulados
  2: { 'AMERICA': 45, 'EUROPA': 78, 'ASIA': 23 }, // Tickets online
  49: { 'AMERICA': 1890, 'EUROPA': 5432, 'ASIA': 2341 }, // Pedidos Zara
  50: { 'AMERICA': 2345, 'EUROPA': 6789, 'ASIA': 3456 } // Pedidos eCommerce
};

// Colores por tipo de indicador
const indicatorColors: Record<number, string> = {
  3: '#00ff00',  // Tiendas abiertas - Verde
  13: '#0080ff', // Tiendas con cierre - Azul
  6: '#ff8000',  // Incidencias - Naranja
  4: '#ff0000',  // Tiendas offline - Rojo
  12: '#ffff00', // Reformas - Amarillo
  5: '#ff00ff',  // Contenidos pendientes - Magenta
  1: '#00ffff',  // Tickets acumulados - Cian
  2: '#80ff80',  // Tickets online - Verde claro
  49: '#8080ff', // Pedidos Zara - Azul claro
  50: '#ff8080'  // Pedidos eCommerce - Rosa
};

// Filtrar indicadores por región
const getIndicadoresPorRegion = (indicadores: any[], region: string) => {
  const resultado: any[] = [];
  const regionKey = regionMapping[region] || region.toUpperCase();

  indicadores.forEach((tipoIndicador: any) => {
    if (!tipoIndicador.indicadores) return;

    tipoIndicador.indicadores.forEach((indicador: any) => {
      if (!indicador.nombre) return;

      const nombreRegion = indicador.nombre.toLowerCase();
      const regionBuscada = regionKey.toLowerCase();

      if (nombreRegion.includes(regionBuscada)) {
        // Buscar valor en parámetros
        let valor = 0;
        if (indicador.parametros && indicador.parametros.length > 0) {
          const numeroElementos = indicador.parametros.find((p: any) =>
            p.descripcion === "NUMERO_ELEMENTOS"
          );
          if (numeroElementos && numeroElementos.valor) {
            valor = parseInt(numeroElementos.valor);
          }
        }

        // Usar valor mock si no hay datos
        if (valor === 0) {
          valor = mockValues[tipoIndicador.idTipoIndicador]?.[regionKey] || Math.floor(Math.random() * 100);
        }

        resultado.push({
          nombre: indicador.nombre,
          descripcion: tipoIndicador.descripcion,
          valor,
          tipo: tipoIndicador.idTipoIndicador,
          label: formatIndicatorName(indicador.nombre, regionKey),
          color: indicatorColors[tipoIndicador.idTipoIndicador] || '#ffffff'
        });
      }
    });
  });

  // Si no hay datos, usar datos mock para la región
  if (resultado.length === 0) {
    const mockData = [
      { tipo: 3, descripcion: 'Tiendas Abiertas', label: 'TIENDAS ABIERTAS' },
      { tipo: 13, descripcion: 'Tiendas con Cierre', label: 'TIENDAS CON CIERRE' },
      { tipo: 6, descripcion: 'Incidencias', label: 'INCIDENCIAS' },
      { tipo: 4, descripcion: 'Tiendas Offline', label: 'TIENDAS OFFLINE' },
      { tipo: 12, descripcion: 'Reformas', label: 'REFORMAS' },
      { tipo: 1, descripcion: 'Tickets Acumulados', label: 'TICKETS ACUMULADOS' }
    ];

    mockData.forEach((mock) => {
      resultado.push({
        nombre: `${mock.label}_${regionKey}`,
        descripcion: mock.descripcion,
        valor: mockValues[mock.tipo]?.[regionKey] || Math.floor(Math.random() * 100),
        tipo: mock.tipo,
        label: mock.label,
        color: indicatorColors[mock.tipo] || '#ffffff'
      });
    });
  }

  return resultado.sort((a, b) => b.valor - a.valor);
};

// Formatear nombre del indicador
const formatIndicatorName = (nombre: string, region: string): string => {
  return nombre
    .replace(`_${region}`, '')
    .replace(/_/g, ' ')
    .toLowerCase()
    .split(' ')
    .map((word: string) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ')
    .toUpperCase(); // Convertir todo a mayúsculas
};

const indicadoresRegion = getIndicadoresPorRegion(indicadores, region);

// Dividir indicadores en grupos de 6 para mostrar sin scroll
const ITEMS_PER_PAGE = 6; // 3 filas x 2 columnas
const indicatorGroups = [];
for (let i = 0; i < indicadoresRegion.length; i += ITEMS_PER_PAGE) {
  indicatorGroups.push(indicadoresRegion.slice(i, i + ITEMS_PER_PAGE));
}

const shouldAnimate = indicatorGroups.length > 1;
const totalIndicators = indicadoresRegion.length;

// Debug logging
console.log(`[IndicatorList] Region: ${region}, Found ${totalIndicators} indicators in ${indicatorGroups.length} groups:`, indicadoresRegion.map(i => `${i.label}: ${i.valor}`));
---

<div class="indicator-list">
  {totalIndicators > 0 ? (
    <div class="indicators-container" data-should-animate={shouldAnimate} data-groups={indicatorGroups.length}>
      {indicatorGroups.map((group, groupIndex) => (
        <div
          class="indicators-page"
          data-page={groupIndex}
          style={groupIndex === 0 ? 'opacity: 1; transform: translateX(0)' : 'opacity: 0; transform: translateX(100%)'}
        >
          <div class="indicators-grid">
            {group.map((indicador: any, index: number) => (
              <div
                class="indicator-item"
                style={`border-left-color: ${indicador.color}; animation-delay: ${index * 0.1}s`}
                data-critical={indicador.tipo === 4 && indicador.valor > 0 ? "true" : "false"}
              >
                <span class="indicator-value">{indicador.valor}</span>
                <span class="indicator-label">{indicador.label}</span>
              </div>
            ))}
          </div>
        </div>
      ))}

      {/* Indicador de página */}
      {shouldAnimate && (
        <div class="page-indicators">
          {indicatorGroups.map((_, index) => (
            <div class="page-dot" data-page={index}></div>
          ))}
        </div>
      )}
    </div>
  ) : (
    <div class="no-data">
      <span>Sin datos para {region.toUpperCase()}</span>
    </div>
  )}
</div>

<style>
  .indicator-list {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'Quicksand Variable', sans-serif;
    overflow: hidden;
    padding: 8px;
    box-sizing: border-box;
    position: relative;
  }

  .indicators-container {
    width: 100%;
    height: 100%;
    position: relative;
    overflow: hidden;
    padding-bottom: 20px; /* Añadido espacio en la parte inferior para los indicadores */
    box-sizing: border-box;
  }

  .indicators-page {
    position: absolute;
    width: 100%;
    height: calc(100% - 20px); /* Reducido para dar espacio a los indicadores */
    top: 0;
    left: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    transform-origin: center;
  }

  .indicators-grid {
    display: grid;
    grid-template-columns: 1fr 1fr; /* 2 columnas */
    grid-template-rows: repeat(3, 1fr); /* 3 filas fijas */
    gap: 8px 12px;
    width: 100%;
    height: 100%;
    align-content: center;
    justify-items: stretch;
    max-height: 100%;
    overflow: hidden;
    padding: 4px;
    box-sizing: border-box;
  }

  .indicator-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 4px;
    font-size: clamp(0.65em, 1.2vmin, 0.8em); /* Aumentado para mejor legibilidad */
    line-height: 1.2; /* Mejorado para mejor espaciado */
    padding: 8px 6px; /* Aumentado padding para mejor presentación */
    background: rgba(0, 0, 0, 0.7); /* Más opaco para mejor contraste */
    border-radius: 6px;
    border-left: 3px solid #00ff00;
    min-height: 45px; /* Aumentado para mejor legibilidad */
    max-height: 65px; /* Aumentado proporcionalmente */
    transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    box-sizing: border-box;
    width: 100%;
    text-align: center;
    overflow: hidden;
    position: relative;
    transform-origin: center;
    /* will-change: transform, opacity; */ /* Comentado para mejorar la nitidez constante */
    -webkit-font-smoothing: antialiased; /* Añadido para mejorar la nitidez en WebKit */
    -moz-osx-font-smoothing: grayscale; /* Añadido para mejorar la nitidez en Firefox */
    text-rendering: optimizeLegibility; /* Añadido para priorizar legibilidad */
  }

  .indicator-item:hover {
    background: rgba(255, 255, 255, 0.15); /* Ligeramente reducido para mejor contraste */
    transform: scale(1.02); /* Reducido de 1.03 a 1.02 para menos distorsión y eliminado translateZ(0) */
    z-index: 2;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25); /* Sombra más sutil */
    /* Mantener nitidez durante hover */
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  /* Animación de entrada para los elementos */
  .indicator-item {
    animation: slideInFromLeft 0.4s ease-out forwards;
    opacity: 0;
    transform: translateX(-20px);
    /* Prevenir blur durante animaciones */
    -webkit-backface-visibility: hidden;
    backface-visibility: hidden;
    -webkit-perspective: 1000px;
    perspective: 1000px;
    /* Mantener nitidez del texto durante animaciones */
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;
  }

  @keyframes slideInFromLeft {
    to {
      opacity: 1;
      transform: translateX(0);
    }
  }

  /* Efecto de pulso para valores críticos */
  .indicator-item[data-critical="true"] {
    animation: criticalPulse 2s ease-in-out infinite;
  }

  @keyframes criticalPulse {
    0%, 100% {
      box-shadow: 0 0 5px rgba(255, 0, 0, 0.3);
    }
    50% {
      box-shadow: 0 0 15px rgba(255, 0, 0, 0.8);
    }
  }

  .indicator-value {
    font-weight: bold;
    color: #ffffff;
    text-align: center;
    font-size: 1.3em; /* Aumentado para mejor legibilidad */
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9); /* Sombra más pronunciada para claridad */
    font-family: 'Roboto Mono Variable', 'Roboto Mono', monospace;
    font-weight: 700;
    font-variant-numeric: tabular-nums;
    letter-spacing: 0.5px;
    order: 1;
    white-space: nowrap;
    /* Mejorar nitidez del texto */
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;
  }

  .indicator-label {
    color: #f0f0f0; /* Más claro para mejor contraste */
    font-size: 0.9em; /* Aumentado para mejor legibilidad */
    font-weight: 600;
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
    text-align: center;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9); /* Sombra más pronunciada */
    width: 100%;
    order: 2;
    line-height: 1.3; /* Mejorado para mejor espaciado */
    max-width: 100%;
    display: block;
    /* Mejorar nitidez del texto */
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;
  }

  /* Page indicators */
  .page-indicators {
    position: absolute;
    bottom: 4px; /* Reducido de 8px a 4px para estar más cerca del borde */
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 8px; /* Aumentado de 6px a 8px para mejor visibilidad */
    z-index: 20; /* Aumentado de 10 a 20 para asegurar que esté por encima */
    pointer-events: none; /* Para evitar interferencias */
  }

  .page-dot {
    width: 10px; /* Aumentado de 8px a 10px */
    height: 10px; /* Aumentado de 8px a 10px */
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.4); /* Más opaco para mejor visibilidad */
    transition: all 0.3s ease;
    border: 1px solid rgba(255, 255, 255, 0.2); /* Añadido borde para definición */
  }

  .page-dot.active {
    background: rgba(255, 255, 255, 0.9); /* Más opaco cuando está activo */
    transform: scale(1.3); /* Ligeramente más grande */
    box-shadow: 0 0 8px rgba(255, 255, 255, 0.5); /* Añadido glow effect */
  }

  /* Responsive adjustments */
  @media (max-width: 1400px) {
    .indicators-grid {
      gap: 6px 10px;
    }

    .indicator-item {
      min-height: 38px;
      max-height: 55px;
      padding: 5px 3px;
      font-size: clamp(0.5em, 1.0vmin, 0.65em);
    }

    .indicator-value {
      font-size: 1.1em;
    }

    .indicator-label {
      font-size: 0.75em; /* Aumentado de 0.65em a 0.75em */
    }
  }

  @media (max-width: 1000px) {
    .indicators-grid {
      gap: 4px 8px;
    }

    .indicator-item {
      min-height: 35px;
      max-height: 50px;
      padding: 4px 2px;
      font-size: clamp(0.45em, 0.9vmin, 0.6em);
    }

    .indicator-value {
      font-size: 1.0em;
    }

    .indicator-label {
      font-size: 0.7em; /* Aumentado de 0.6em a 0.7em */
    }
  }

  @media (max-width: 800px) {
    .indicator-item {
      min-height: 32px;
      max-height: 45px;
      padding: 3px 2px;
      font-size: clamp(0.4em, 0.8vmin, 0.55em);
    }

    .indicator-value {
      font-size: 0.9em;
    }

    .indicator-label {
      font-size: 0.65em; /* Aumentado de 0.55em a 0.65em */
    }
  }

  .no-data {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    color: rgba(255, 255, 255, 0.6);
    font-size: clamp(0.8em, 1.5vmin, 1.0em);
  }
</style>

<script>
  import { LenisAnimator, lenisUtils } from '../utils/lenisAnimations.ts';

  // Initialize Lenis animator for enhanced animations
  const lenisAnimator = new LenisAnimator({
    duration: 0.8,
    easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
  });

  // Lenis-inspired animations directly implemented
  // Funciones de animación suave tipo Lenis
  function lenisStyleAnimate(element: HTMLElement, properties: any, duration: number = 0.8) {
    const easing = 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'; // Lenis easing
    element.style.transition = `all ${duration}s ${easing}`;

    Object.keys(properties).forEach(key => {
      if (key === 'transform' || key === 'opacity') {
        element.style[key] = properties[key];
      }
    });
  }

  function lenisStyleStagger(elements: NodeListOf<Element>, properties: any, staggerDelay: number = 0.08) {
    elements.forEach((element, index) => {
      setTimeout(() => {
        lenisStyleAnimate(element as HTMLElement, properties);
      }, index * staggerDelay * 1000);
    });
  }

  // Inicializar paginación para indicadores sin scroll con animaciones Lenis
  function initializeIndicatorPagination() {
    const containers = document.querySelectorAll('.indicators-container');

    containers.forEach((container) => {
      const htmlContainer = container as HTMLElement;
      const shouldAnimate = htmlContainer.dataset.shouldAnimate === 'true';

      if (!shouldAnimate) {
        // Aplicar animación de entrada inicial incluso sin paginación
        const items = document.querySelectorAll('.indicator-item');
        lenisStyleStagger(items, {
          opacity: '1',
          transform: 'translateY(0) scale(1)'
        }, 0.08);
        return;
      }

      const pages = htmlContainer.querySelectorAll('.indicators-page');
      const dots = htmlContainer.querySelectorAll('.page-dot');
      let currentPage = 0;
      const totalPages = pages.length;

      if (totalPages <= 1) return;

      // Función para actualizar la visualización de páginas con animaciones suaves tipo Lenis
      function updatePageDisplay() {
        pages.forEach((page, index) => {
          const pageElement = page as HTMLElement;

          if (index === currentPage) {
            // Página actual - animación de entrada suave
            lenisStyleAnimate(pageElement, {
              opacity: '1',
              transform: 'translateX(0) scale(1)'
            }, 0.8);
            pageElement.style.zIndex = '2';

            // Animar elementos individuales con efecto Lenis
            setTimeout(() => {
              const items = pageElement.querySelectorAll('.indicator-item');
              items.forEach((item, itemIndex) => {
                const itemElement = item as HTMLElement;
                itemElement.style.opacity = '0';
                itemElement.style.transform = 'translateY(20px) scale(0.95)';

                setTimeout(() => {
                  lenisStyleAnimate(itemElement, {
                    opacity: '1',
                    transform: 'translateY(0) scale(1)'
                  }, 0.6);
                }, itemIndex * 80); // Stagger de 80ms estilo Lenis
              });
            }, 100);

          } else {
            // Páginas ocultas - animación de salida suave
            const direction = index < currentPage ? '-100%' : '100%';
            lenisStyleAnimate(pageElement, {
              opacity: '0',
              transform: `translateX(${direction}) scale(0.98)`
            }, 0.8);
            pageElement.style.zIndex = '1';
          }
        });

        // Actualizar indicadores de página con animación suave
        dots.forEach((dot, index) => {
          const dotElement = dot as HTMLElement;

          if (index === currentPage) {
            dotElement.classList.add('active');
            lenisStyleAnimate(dotElement, {
              transform: 'scale(1.3)'
            }, 0.4);
            dotElement.style.background = 'rgba(255, 255, 255, 0.9)';
          } else {
            dotElement.classList.remove('active');
            lenisStyleAnimate(dotElement, {
              transform: 'scale(1)'
            }, 0.4);
            dotElement.style.background = 'rgba(255, 255, 255, 0.4)';
          }
        });
      }

      // Función para ir a la siguiente página con transición suave
      function nextPage() {
        const previousPage = currentPage;
        currentPage = (currentPage + 1) % totalPages;

        // Pre-animación de salida de la página actual
        const currentPageElement = pages[previousPage] as HTMLElement;
        const items = currentPageElement.querySelectorAll('.indicator-item');

        items.forEach((item, index) => {
          setTimeout(() => {
            lenisStyleAnimate(item as HTMLElement, {
              opacity: '0.7',
              transform: 'translateY(-10px) scale(0.98)'
            }, 0.4);
          }, index * 40);
        });

        // Actualizar display después de la pre-animación
        setTimeout(() => {
          updatePageDisplay();
        }, 200);
      }

      // Configurar rotación automática con timing suave tipo Lenis
      let rotationInterval: number | null = null;
      const rotationDelay = 6000; // 6 segundos por página

      function startRotation() {
        if (rotationInterval) return;
        rotationInterval = window.setInterval(nextPage, rotationDelay);
      }

      function stopRotation() {
        if (rotationInterval) {
          clearInterval(rotationInterval);
          rotationInterval = null;
        }
      }

      // Configurar estado inicial con animación de entrada
      setTimeout(() => {
        updatePageDisplay();

        // Aplicar efectos hover tipo Lenis a todos los items
        const allItems = htmlContainer.querySelectorAll('.indicator-item');
        allItems.forEach(item => {
          const itemElement = item as HTMLElement;
          itemElement.addEventListener('mouseenter', () => {
            lenisStyleAnimate(itemElement, {
              transform: 'scale(1.03)'
            }, 0.3);
          });

          itemElement.addEventListener('mouseleave', () => {
            lenisStyleAnimate(itemElement, {
              transform: 'scale(1)'
            }, 0.3);
          });
        });
      }, 100);

      // Iniciar rotación con delay para permitir animación inicial
      setTimeout(startRotation, 1000);

      // Pausar/reanudar en hover con transiciones suaves
      htmlContainer.addEventListener('mouseenter', () => {
        stopRotation();
        lenisStyleAnimate(htmlContainer, {
          transform: 'scale(1.01)'
        }, 0.3);
      });

      htmlContainer.addEventListener('mouseleave', () => {
        lenisStyleAnimate(htmlContainer, {
          transform: 'scale(1)'
        }, 0.3);
        setTimeout(startRotation, 500); // Delay antes de reanudar
      });
    });
  }

  // Inicializar con múltiples intentos para garantizar carga completa
  function initWithLenisRetry() {
    setTimeout(initializeIndicatorPagination, 100);
    setTimeout(initializeIndicatorPagination, 300);
    setTimeout(initializeIndicatorPagination, 600);
  }

  // Inicializar cuando el DOM esté listo
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initWithLenisRetry);
  } else {
    initWithLenisRetry();
  }

  // Reinicializar después de que Astro termine de hidrar con suavidad
  setTimeout(() => {
    initWithLenisRetry();

    // Aplicar animaciones de entrada globales tipo Lenis
    const allItems = document.querySelectorAll('.indicator-item');
    allItems.forEach((item, index) => {
      const itemElement = item as HTMLElement;
      itemElement.style.opacity = '0';
      itemElement.style.transform = 'translateY(20px) scale(0.95)';

      setTimeout(() => {
        lenisStyleAnimate(itemElement, {
          opacity: '1',
          transform: 'translateY(0) scale(1)'
        }, 0.8);
      }, index * 50 + 200);
    });
  }, 800);
</script>
