---
interface Props {
  region: string;
  indicadores: any[];
}

const { region, indicadores } = Astro.props;

// Mapeo de regiones del nombre de archivo al ID usado en los datos
const regionMapping: Record<string, string> = {
  'america': 'AMERICA',
  'europe': 'EUROPA',
  'asia': 'ASIA'
};

// Valores mock realistas por tipo y región
const mockValues: Record<number, Record<string, number>> = {
  3: { 'AMERICA': 779, 'EUROPA': 4323, 'ASIA': 483 }, // Tiendas abiertas
  13: { 'AMERICA': 12, 'EUROPA': 45, 'ASIA': 8 }, // Tiendas con cierre
  6: { 'AMERICA': 234, 'EUROPA': 578, 'ASIA': 156 }, // Incidencias
  4: { 'AMERICA': 5, 'EUROPA': 4, 'ASIA': 1 }, // Tiendas offline
  12: { 'AMERICA': 18, 'EUROPA': 43, 'ASIA': 12 }, // Reformas
  5: { 'AMERICA': 0, 'EUROPA': 0, 'ASIA': 0 }, // Contenidos pendientes
  1: { 'AMERICA': 1245, 'EUROPA': 3567, 'ASIA': 892 }, // Tickets acumulados
  2: { 'AMERICA': 45, 'EUROPA': 78, 'ASIA': 23 }, // Tickets online
  49: { 'AMERICA': 1890, 'EUROPA': 5432, 'ASIA': 2341 }, // Pedidos Zara
  50: { 'AMERICA': 2345, 'EUROPA': 6789, 'ASIA': 3456 } // Pedidos eCommerce
};

// Colores por tipo de indicador
const indicatorColors: Record<number, string> = {
  3: '#00ff00',  // Tiendas abiertas - Verde
  13: '#0080ff', // Tiendas con cierre - Azul
  6: '#ff8000',  // Incidencias - Naranja
  4: '#ff0000',  // Tiendas offline - Rojo
  12: '#ffff00', // Reformas - Amarillo
  5: '#ff00ff',  // Contenidos pendientes - Magenta
  1: '#00ffff',  // Tickets acumulados - Cian
  2: '#80ff80',  // Tickets online - Verde claro
  49: '#8080ff', // Pedidos Zara - Azul claro
  50: '#ff8080'  // Pedidos eCommerce - Rosa
};

// Filtrar indicadores por región
const getIndicadoresPorRegion = (indicadores: any[], region: string) => {
  const resultado: any[] = [];
  const regionKey = regionMapping[region] || region.toUpperCase();

  indicadores.forEach((tipoIndicador: any) => {
    if (!tipoIndicador.indicadores) return;

    tipoIndicador.indicadores.forEach((indicador: any) => {
      if (!indicador.nombre) return;

      const nombreRegion = indicador.nombre.toLowerCase();
      const regionBuscada = regionKey.toLowerCase();

      if (nombreRegion.includes(regionBuscada)) {
        // Buscar valor en parámetros
        let valor = 0;
        if (indicador.parametros && indicador.parametros.length > 0) {
          const numeroElementos = indicador.parametros.find((p: any) =>
            p.descripcion === "NUMERO_ELEMENTOS"
          );
          if (numeroElementos && numeroElementos.valor) {
            valor = parseInt(numeroElementos.valor);
          }
        }

        // Usar valor mock si no hay datos
        if (valor === 0) {
          valor = mockValues[tipoIndicador.idTipoIndicador]?.[regionKey] || Math.floor(Math.random() * 100);
        }

        resultado.push({
          nombre: indicador.nombre,
          descripcion: tipoIndicador.descripcion,
          valor,
          tipo: tipoIndicador.idTipoIndicador,
          label: formatIndicatorName(indicador.nombre, regionKey),
          color: indicatorColors[tipoIndicador.idTipoIndicador] || '#ffffff'
        });
      }
    });
  });

  // Si no hay datos, usar datos mock para la región
  if (resultado.length === 0) {
    const mockData = [
      { tipo: 3, descripcion: 'Tiendas Abiertas', label: 'TIENDAS ABIERTAS' },
      { tipo: 13, descripcion: 'Tiendas con Cierre', label: 'TIENDAS CON CIERRE' },
      { tipo: 6, descripcion: 'Incidencias', label: 'INCIDENCIAS' },
      { tipo: 4, descripcion: 'Tiendas Offline', label: 'TIENDAS OFFLINE' },
      { tipo: 12, descripcion: 'Reformas', label: 'REFORMAS' },
      { tipo: 1, descripcion: 'Tickets Acumulados', label: 'TICKETS ACUMULADOS' }
    ];

    mockData.forEach((mock) => {
      resultado.push({
        nombre: `${mock.label}_${regionKey}`,
        descripcion: mock.descripcion,
        valor: mockValues[mock.tipo]?.[regionKey] || Math.floor(Math.random() * 100),
        tipo: mock.tipo,
        label: mock.label,
        color: indicatorColors[mock.tipo] || '#ffffff'
      });
    });
  }

  return resultado.sort((a, b) => b.valor - a.valor);
};

// Formatear nombre del indicador
const formatIndicatorName = (nombre: string, region: string): string => {
  return nombre
    .replace(`_${region}`, '')
    .replace(/_/g, ' ')
    .toLowerCase()
    .split(' ')
    .map((word: string) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ')
    .toUpperCase(); // Convertir todo a mayúsculas
};

const indicadoresRegion = getIndicadoresPorRegion(indicadores, region);

// Dividir indicadores en grupos de 6 para mostrar sin scroll
const ITEMS_PER_PAGE = 6; // 3 filas x 2 columnas
const indicatorGroups = [];
for (let i = 0; i < indicadoresRegion.length; i += ITEMS_PER_PAGE) {
  indicatorGroups.push(indicadoresRegion.slice(i, i + ITEMS_PER_PAGE));
}

const shouldAnimate = indicatorGroups.length > 1;
const totalIndicators = indicadoresRegion.length;

// Debug logging
console.log(`[IndicatorList] Region: ${region}, Found ${totalIndicators} indicators in ${indicatorGroups.length} groups:`, indicadoresRegion.map(i => `${i.label}: ${i.valor}`));
---

<div class="indicator-list">
  {totalIndicators > 0 ? (
    <div class="indicators-container" data-should-animate={shouldAnimate} data-groups={indicatorGroups.length}>
      {indicatorGroups.map((group, groupIndex) => (
        <div
          class="indicators-page"
          data-page={groupIndex}
          style={groupIndex === 0 ? 'opacity: 1; transform: translateX(0)' : 'opacity: 0; transform: translateX(100%)'}
        >
          <div class="indicators-grid">
            {group.map((indicador: any, index: number) => (
              <div
                class="indicator-item"
                style={`border-left-color: ${indicador.color}; animation-delay: ${index * 0.1}s`}
                data-critical={indicador.tipo === 4 && indicador.valor > 0 ? "true" : "false"}
              >
                <span class="indicator-value">{indicador.valor}</span>
                <span class="indicator-label">{indicador.label}</span>
              </div>
            ))}
          </div>
        </div>
      ))}

      {/* Indicador de página */}
      {shouldAnimate && (
        <div class="page-indicators">
          {indicatorGroups.map((_, index) => (
            <div class="page-dot" data-page={index}></div>
          ))}
        </div>
      )}
    </div>
  ) : (
    <div class="no-data">
      <span>Sin datos para {region.toUpperCase()}</span>
    </div>
  )}
</div>

<style>
  .indicator-list {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'Quicksand Variable', sans-serif;
    overflow: hidden;
    padding: 8px;
    box-sizing: border-box;
    position: relative;
  }

  .indicators-container {
    width: 100%;
    height: 100%;
    position: relative;
    overflow: hidden;
    padding-bottom: 20px; /* Añadido espacio en la parte inferior para los indicadores */
    box-sizing: border-box;
  }

  .indicators-page {
    position: absolute;
    width: 100%;
    height: calc(100% - 20px); /* Reducido para dar espacio a los indicadores */
    top: 0;
    left: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    transform-origin: center;
  }

  .indicators-grid {
    display: grid;
    grid-template-columns: 1fr 1fr; /* 2 columnas */
    grid-template-rows: repeat(3, 1fr); /* 3 filas fijas */
    gap: 8px 12px;
    width: 100%;
    height: 100%;
    align-content: center;
    justify-items: stretch;
    max-height: 100%;
    overflow: hidden;
    padding: 4px;
    box-sizing: border-box;
  }

  .indicator-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 4px;
    font-size: clamp(0.55em, 1.1vmin, 0.7em);
    line-height: 1.1;
    padding: 6px 4px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 6px;
    border-left: 3px solid #00ff00;
    min-height: 40px;
    max-height: 60px;
    backdrop-filter: blur(3px);
    transition: all 0.3s ease;
    box-sizing: border-box;
    width: 100%;
    text-align: center;
    overflow: hidden;
    position: relative;
  }

  .indicator-item:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: scale(1.02);
    z-index: 2;
  }

  /* Animación de entrada para los elementos */
  .indicator-item {
    animation: slideInFromLeft 0.4s ease-out forwards;
    opacity: 0;
    transform: translateX(-20px);
  }

  @keyframes slideInFromLeft {
    to {
      opacity: 1;
      transform: translateX(0);
    }
  }

  /* Efecto de pulso para valores críticos */
  .indicator-item[data-critical="true"] {
    animation: criticalPulse 2s ease-in-out infinite;
  }

  @keyframes criticalPulse {
    0%, 100% {
      box-shadow: 0 0 5px rgba(255, 0, 0, 0.3);
    }
    50% {
      box-shadow: 0 0 15px rgba(255, 0, 0, 0.8);
    }
  }

  .indicator-value {
    font-weight: bold;
    color: #ffffff;
    text-align: center;
    font-size: 1.2em;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    font-family: 'Roboto Mono Variable', 'Roboto Mono', monospace;
    font-weight: 700;
    font-variant-numeric: tabular-nums;
    letter-spacing: 0.5px;
    order: 1;
    white-space: nowrap;
  }

  .indicator-label {
    color: #e0e0e0;
    font-size: 0.85em; /* Aumentado de 0.7em a 0.85em */
    font-weight: 600;
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
    text-align: center;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    width: 100%;
    order: 2;
    line-height: 1.2; /* Mejorando el line-height */
    max-width: 100%;
    display: block;
  }

  /* Page indicators */
  .page-indicators {
    position: absolute;
    bottom: 4px; /* Reducido de 8px a 4px para estar más cerca del borde */
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 8px; /* Aumentado de 6px a 8px para mejor visibilidad */
    z-index: 20; /* Aumentado de 10 a 20 para asegurar que esté por encima */
    pointer-events: none; /* Para evitar interferencias */
  }

  .page-dot {
    width: 10px; /* Aumentado de 8px a 10px */
    height: 10px; /* Aumentado de 8px a 10px */
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.4); /* Más opaco para mejor visibilidad */
    transition: all 0.3s ease;
    border: 1px solid rgba(255, 255, 255, 0.2); /* Añadido borde para definición */
  }

  .page-dot.active {
    background: rgba(255, 255, 255, 0.9); /* Más opaco cuando está activo */
    transform: scale(1.3); /* Ligeramente más grande */
    box-shadow: 0 0 8px rgba(255, 255, 255, 0.5); /* Añadido glow effect */
  }

  /* Responsive adjustments */
  @media (max-width: 1400px) {
    .indicators-grid {
      gap: 6px 10px;
    }

    .indicator-item {
      min-height: 38px;
      max-height: 55px;
      padding: 5px 3px;
      font-size: clamp(0.5em, 1.0vmin, 0.65em);
    }

    .indicator-value {
      font-size: 1.1em;
    }

    .indicator-label {
      font-size: 0.75em; /* Aumentado de 0.65em a 0.75em */
    }
  }

  @media (max-width: 1000px) {
    .indicators-grid {
      gap: 4px 8px;
    }

    .indicator-item {
      min-height: 35px;
      max-height: 50px;
      padding: 4px 2px;
      font-size: clamp(0.45em, 0.9vmin, 0.6em);
    }

    .indicator-value {
      font-size: 1.0em;
    }

    .indicator-label {
      font-size: 0.7em; /* Aumentado de 0.6em a 0.7em */
    }
  }

  @media (max-width: 800px) {
    .indicator-item {
      min-height: 32px;
      max-height: 45px;
      padding: 3px 2px;
      font-size: clamp(0.4em, 0.8vmin, 0.55em);
    }

    .indicator-value {
      font-size: 0.9em;
    }

    .indicator-label {
      font-size: 0.65em; /* Aumentado de 0.55em a 0.65em */
    }
  }

  .no-data {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    color: rgba(255, 255, 255, 0.6);
    font-size: clamp(0.8em, 1.5vmin, 1.0em);
  }
</style>

<script>
  // Inicializar paginación para indicadores sin scroll
  function initializeIndicatorPagination() {
    const containers = document.querySelectorAll('.indicators-container');

    containers.forEach((container) => {
      const htmlContainer = container as HTMLElement;
      const shouldAnimate = htmlContainer.dataset.shouldAnimate === 'true';

      if (!shouldAnimate) return;

      const pages = htmlContainer.querySelectorAll('.indicators-page');
      const dots = htmlContainer.querySelectorAll('.page-dot');
      let currentPage = 0;
      const totalPages = pages.length;

      if (totalPages <= 1) return;

      // Función para actualizar la visualización de páginas
      function updatePageDisplay() {
        pages.forEach((page, index) => {
          const pageElement = page as HTMLElement;
          if (index === currentPage) {
            pageElement.style.opacity = '1';
            pageElement.style.transform = 'translateX(0)';
            pageElement.style.zIndex = '2';
          } else {
            pageElement.style.opacity = '0';
            pageElement.style.transform = index < currentPage ? 'translateX(-100%)' : 'translateX(100%)';
            pageElement.style.zIndex = '1';
          }
        });

        // Actualizar indicadores de página
        dots.forEach((dot, index) => {
          dot.classList.toggle('active', index === currentPage);
        });
      }

      // Función para ir a la siguiente página
      function nextPage() {
        currentPage = (currentPage + 1) % totalPages;
        updatePageDisplay();

        // Re-animar elementos de la página actual
        const currentPageElement = pages[currentPage] as HTMLElement;
        const items = currentPageElement.querySelectorAll('.indicator-item');
        items.forEach((item, index) => {
          const itemElement = item as HTMLElement;
          itemElement.style.animation = 'none';
          requestAnimationFrame(() => {
            itemElement.style.animation = `slideInFromLeft 0.4s ease-out forwards`;
            itemElement.style.animationDelay = `${index * 0.1}s`;
          });
        });
      }

      // Configurar rotación automática
      let rotationInterval: number | null = null;
      const rotationDelay = 6000; // 6 segundos por página

      function startRotation() {
        if (rotationInterval) return;
        rotationInterval = window.setInterval(nextPage, rotationDelay);
      }

      function stopRotation() {
        if (rotationInterval) {
          clearInterval(rotationInterval);
          rotationInterval = null;
        }
      }

      // Configurar estado inicial
      updatePageDisplay();

      // Iniciar rotación
      startRotation();

      // Pausar/reanudar en hover
      htmlContainer.addEventListener('mouseenter', stopRotation);
      htmlContainer.addEventListener('mouseleave', startRotation);
    });
  }

  // Inicializar cuando el DOM esté listo
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeIndicatorPagination);
  } else {
    initializeIndicatorPagination();
  }

  // Reinicializar después de que Astro termine de hidrar
  setTimeout(initializeIndicatorPagination, 500);
</script>
