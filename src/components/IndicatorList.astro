---
interface Props {
  region: string;
  indicadores: any[];
}

const { region, indicadores } = Astro.props;

// Mapeo de regiones del nombre de archivo al ID usado en los datos
const regionMapping: Record<string, string> = {
  'america': 'AMERICA',
  'europe': 'EUROPA',
  'asia': 'ASIA'
};

// Valores mock realistas por tipo y región
const mockValues: Record<number, Record<string, number>> = {
  3: { 'AMERICA': 779, 'EUROPA': 4323, 'ASIA': 483 }, // Tiendas abiertas
  13: { 'AMERICA': 12, 'EUROPA': 45, 'ASIA': 8 }, // Tiendas con cierre
  6: { 'AMERICA': 234, 'EUROPA': 578, 'ASIA': 156 }, // Incidencias
  4: { 'AMERICA': 5, 'EUROPA': 4, 'ASIA': 1 }, // Tiendas offline
  12: { 'AMERICA': 18, 'EUROPA': 43, 'ASIA': 12 }, // Reformas
  5: { 'AMERICA': 0, 'EUROPA': 0, 'ASIA': 0 }, // Contenidos pendientes
  1: { 'AMERICA': 1245, 'EUROPA': 3567, 'ASIA': 892 }, // Tickets acumulados
  2: { 'AMERICA': 45, 'EUROPA': 78, 'ASIA': 23 }, // Tickets online
  49: { 'AMERICA': 1890, 'EUROPA': 5432, 'ASIA': 2341 }, // Pedidos Zara
  50: { 'AMERICA': 2345, 'EUROPA': 6789, 'ASIA': 3456 } // Pedidos eCommerce
};

// Colores por tipo de indicador
const indicatorColors: Record<number, string> = {
  3: '#00ff00',  // Tiendas abiertas - Verde
  13: '#0080ff', // Tiendas con cierre - Azul
  6: '#ff8000',  // Incidencias - Naranja
  4: '#ff0000',  // Tiendas offline - Rojo
  12: '#ffff00', // Reformas - Amarillo
  5: '#ff00ff',  // Contenidos pendientes - Magenta
  1: '#00ffff',  // Tickets acumulados - Cian
  2: '#80ff80',  // Tickets online - Verde claro
  49: '#8080ff', // Pedidos Zara - Azul claro
  50: '#ff8080'  // Pedidos eCommerce - Rosa
};

// Filtrar indicadores por región
const getIndicadoresPorRegion = (indicadores: any[], region: string) => {
  const resultado: any[] = [];
  const regionKey = regionMapping[region] || region.toUpperCase();

  indicadores.forEach((tipoIndicador: any) => {
    if (!tipoIndicador.indicadores) return;

    tipoIndicador.indicadores.forEach((indicador: any) => {
      if (!indicador.nombre) return;

      const nombreRegion = indicador.nombre.toLowerCase();
      const regionBuscada = regionKey.toLowerCase();

      if (nombreRegion.includes(regionBuscada)) {
        // Buscar valor en parámetros
        let valor = 0;
        if (indicador.parametros && indicador.parametros.length > 0) {
          const numeroElementos = indicador.parametros.find((p: any) =>
            p.descripcion === "NUMERO_ELEMENTOS"
          );
          if (numeroElementos && numeroElementos.valor) {
            valor = parseInt(numeroElementos.valor);
          }
        }

        // Usar valor mock si no hay datos
        if (valor === 0) {
          valor = mockValues[tipoIndicador.idTipoIndicador]?.[regionKey] || Math.floor(Math.random() * 100);
        }

        resultado.push({
          nombre: indicador.nombre,
          descripcion: tipoIndicador.descripcion,
          valor,
          tipo: tipoIndicador.idTipoIndicador,
          label: formatIndicatorName(indicador.nombre, regionKey),
          color: indicatorColors[tipoIndicador.idTipoIndicador] || '#ffffff'
        });
      }
    });
  });

  // Si no hay datos, usar datos mock para la región
  if (resultado.length === 0) {
    const mockData = [
      { tipo: 3, descripcion: 'Tiendas Abiertas', label: 'TIENDAS ABIERTAS' },
      { tipo: 13, descripcion: 'Tiendas con Cierre', label: 'TIENDAS CON CIERRE' },
      { tipo: 6, descripcion: 'Incidencias', label: 'INCIDENCIAS' },
      { tipo: 4, descripcion: 'Tiendas Offline', label: 'TIENDAS OFFLINE' },
      { tipo: 12, descripcion: 'Reformas', label: 'REFORMAS' },
      { tipo: 1, descripcion: 'Tickets Acumulados', label: 'TICKETS ACUMULADOS' }
    ];

    mockData.forEach((mock) => {
      resultado.push({
        nombre: `${mock.label}_${regionKey}`,
        descripcion: mock.descripcion,
        valor: mockValues[mock.tipo]?.[regionKey] || Math.floor(Math.random() * 100),
        tipo: mock.tipo,
        label: mock.label,
        color: indicatorColors[mock.tipo] || '#ffffff'
      });
    });
  }

  return resultado.sort((a, b) => b.valor - a.valor);
};

// Formatear nombre del indicador
const formatIndicatorName = (nombre: string, region: string): string => {
  return nombre
    .replace(`_${region}`, '')
    .replace(/_/g, ' ')
    .toLowerCase()
    .split(' ')
    .map((word: string) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ')
    .toUpperCase(); // Convertir todo a mayúsculas
};

const indicadoresRegion = getIndicadoresPorRegion(indicadores, region);

// Dividir indicadores en grupos de 6 para mostrar sin scroll
const ITEMS_PER_PAGE = 6; // 3 filas x 2 columnas
const indicatorGroups = [];
for (let i = 0; i < indicadoresRegion.length; i += ITEMS_PER_PAGE) {
  indicatorGroups.push(indicadoresRegion.slice(i, i + ITEMS_PER_PAGE));
}

const shouldAnimate = indicatorGroups.length > 1;
const totalIndicators = indicadoresRegion.length;

// Debug logging
console.log(`[IndicatorList] Region: ${region}, Found ${totalIndicators} indicators in ${indicatorGroups.length} groups:`, indicadoresRegion.map(i => `${i.label}: ${i.valor}`));
---

<div class="indicator-list">
  {totalIndicators > 0 ? (
    <div class="indicators-container" data-should-animate={shouldAnimate} data-groups={indicatorGroups.length}>
      {indicatorGroups.map((group, groupIndex) => (
        <div
          class="indicators-page"
          data-page={groupIndex}
          style={groupIndex === 0 ? 'opacity: 1; transform: translateX(0)' : 'opacity: 0; transform: translateX(100%)'}
        >
          <div class="indicators-grid">
            {group.map((indicador: any, index: number) => (
              <div
                class="indicator-item"
                style={`border-left-color: ${indicador.color}; animation-delay: ${index * 0.1}s`}
              >
                <span class="indicator-value">{indicador.valor}</span>
                <span class="indicator-label">{indicador.label}</span>
              </div>
            ))}
          </div>
        </div>
      ))}
    </div>
  ) : (
    <div class="no-data">
      <span>Sin datos para {region.toUpperCase()}</span>
    </div>
  )}
</div>

<style>
  .indicator-list {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'Quicksand Variable', sans-serif;
    overflow: hidden;
    padding: 8px;
    box-sizing: border-box;
    position: relative;
  }

  .indicators-container {
    width: 100%;
    height: 100%;
    position: relative;
    overflow: hidden;
    box-sizing: border-box;
  }

  .indicators-page {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    transform-origin: center;
  }

  .indicators-grid {
    display: grid;
    grid-template-columns: 1fr 1fr; /* 2 columnas */
    grid-template-rows: repeat(3, 1fr); /* 3 filas fijas */
    gap: 8px 12px;
    width: 100%;
    height: 100%;
    align-content: center;
    justify-items: stretch;
    max-height: 100%;
    overflow: hidden;
    padding: 4px;
    box-sizing: border-box;
  }

  .indicator-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 4px;
    font-size: clamp(0.65em, 1.2vmin, 0.8em);
    line-height: 1.2;
    padding: 8px 6px;
    background: rgba(0, 0, 0, 0.7);
    border-radius: 6px;
    border-left: 3px solid #00ff00;
    min-height: 45px;
    max-height: 65px;
    transition: none; /* Removed transitions for minimal design */
    box-sizing: border-box;
    width: 100%;
    text-align: center;
    overflow: hidden;
    position: relative;
    transform-origin: center;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;
  }

  /* Animación de entrada para los elementos */
  .indicator-item {
    animation: slideInFromLeft 0.4s ease-out forwards;
    opacity: 0;
    transform: translateX(-20px);
    /* Prevenir blur durante animaciones */
    -webkit-backface-visibility: hidden;
    backface-visibility: hidden;
    -webkit-perspective: 1000px;
    perspective: 1000px;
    /* Mantener nitidez del texto durante animaciones */
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;
  }

  @keyframes slideInFromLeft {
    to {
      opacity: 1;
      transform: translateX(0);
    }
  }

  .indicator-value {
    font-weight: bold;
    color: #ffffff;
    text-align: center;
    font-size: 1.3em; /* Aumentado para mejor legibilidad */
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9); /* Sombra más pronunciada para claridad */
    font-family: 'Roboto Mono Variable', 'Roboto Mono', monospace;
    font-weight: 700;
    font-variant-numeric: tabular-nums;
    letter-spacing: 0.5px;
    order: 1;
    white-space: nowrap;
    /* Mejorar nitidez del texto */
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;
  }

  .indicator-label {
    color: #f0f0f0; /* Más claro para mejor contraste */
    font-size: 0.9em; /* Aumentado para mejor legibilidad */
    font-weight: 600;
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
    text-align: center;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9); /* Sombra más pronunciada */
    width: 100%;
    order: 2;
    line-height: 1.3; /* Mejorado para mejor espaciado */
    max-width: 100%;
    display: block;
    /* Mejorar nitidez del texto */
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;
  }

  /* Page indicators - HIDDEN */
  /*
  .page-indicators {
    position: absolute;
    bottom: 4px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 8px;
    z-index: 20;
    pointer-events: none;
  }

  .page-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.4);
    transition: all 0.3s ease;
    border: 1px solid rgba(255, 255, 255, 0.2);
  }

  .page-dot.active {
    background: rgba(255, 255, 255, 0.9);
    transform: scale(1.3);
    box-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
  }
  */

  /* Responsive adjustments */
  @media (max-width: 1400px) {
    .indicators-grid {
      gap: 6px 10px;
    }

    .indicator-item {
      min-height: 38px;
      max-height: 55px;
      padding: 5px 3px;
      font-size: clamp(0.5em, 1.0vmin, 0.65em);
    }

    .indicator-value {
      font-size: 1.1em;
    }

    .indicator-label {
      font-size: 0.75em; /* Aumentado de 0.65em a 0.75em */
    }
  }

  @media (max-width: 1000px) {
    .indicators-grid {
      gap: 4px 8px;
    }

    .indicator-item {
      min-height: 35px;
      max-height: 50px;
      padding: 4px 2px;
      font-size: clamp(0.45em, 0.9vmin, 0.6em);
    }

    .indicator-value {
      font-size: 1.0em;
    }

    .indicator-label {
      font-size: 0.7em; /* Aumentado de 0.6em a 0.7em */
    }
  }

  @media (max-width: 800px) {
    .indicator-item {
      min-height: 32px;
      max-height: 45px;
      padding: 3px 2px;
      font-size: clamp(0.4em, 0.8vmin, 0.55em);
    }

    .indicator-value {
      font-size: 0.9em;
    }

    .indicator-label {
      font-size: 0.65em; /* Aumentado de 0.55em a 0.65em */
    }
  }

  .no-data {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    color: rgba(255, 255, 255, 0.6);
    font-size: clamp(0.8em, 1.5vmin, 1.0em);
  }
</style>

<script>
  import { gsap } from 'gsap';

  // Minimal GSAP pagination for IndicatorList - no hover effects
  function initializeIndicatorPagination() {
    const containers = document.querySelectorAll('.indicators-container');

    containers.forEach((container) => {
      const htmlContainer = container as HTMLElement;
      const shouldAnimate = htmlContainer.dataset.shouldAnimate === 'true';

      if (!shouldAnimate) {
        return;
      }

      const pages = htmlContainer.querySelectorAll('.indicators-page');
      const dots = htmlContainer.querySelectorAll('.page-dot');
      let currentPage = 0;
      const totalPages = pages.length;

      if (totalPages <= 1) return;

      // Simple page transition function using GSAP
      function updatePageDisplay() {
        pages.forEach((page, index) => {
          const pageElement = page as HTMLElement;

          if (index === currentPage) {
            // Show current page with smooth fade in
            gsap.to(pageElement, {
              opacity: 1,
              x: 0,
              duration: 0.6,
              ease: "power2.out"
            });
            pageElement.style.zIndex = '2';
          } else {
            // Hide other pages
            const direction = index < currentPage ? -100 : 100;
            gsap.to(pageElement, {
              opacity: 0,
              x: direction,
              duration: 0.6,
              ease: "power2.inOut"
            });
            pageElement.style.zIndex = '1';
          }
        });

        // Update page dots
        dots.forEach((dot, index) => {
          const dotElement = dot as HTMLElement;
          if (index === currentPage) {
            dotElement.classList.add('active');
            gsap.to(dotElement, {
              scale: 1.3,
              duration: 0.3,
              ease: "power2.out"
            });
            dotElement.style.background = 'rgba(255, 255, 255, 0.9)';
          } else {
            dotElement.classList.remove('active');
            gsap.to(dotElement, {
              scale: 1,
              duration: 0.3,
              ease: "power2.out"
            });
            dotElement.style.background = 'rgba(255, 255, 255, 0.4)';
          }
        });
      }

      // Next page function
      function nextPage() {
        currentPage = (currentPage + 1) % totalPages;
        updatePageDisplay();
      }

      // Auto-rotation setup
      let rotationInterval: number | null = null;
      const rotationDelay = 6000; // 6 seconds per page

      function startRotation() {
        if (rotationInterval) return;
        rotationInterval = window.setInterval(nextPage, rotationDelay);
      }

      function stopRotation() {
        if (rotationInterval) {
          clearInterval(rotationInterval);
          rotationInterval = null;
        }
      }

      // Initialize and start rotation
      updatePageDisplay();
      setTimeout(startRotation, 1000);

      // Pause on hover (container only, no individual item effects)
      htmlContainer.addEventListener('mouseenter', stopRotation);
      htmlContainer.addEventListener('mouseleave', () => {
        setTimeout(startRotation, 500);
      });
    });
  }

  // Initialize when DOM is ready
  function init() {
    initializeIndicatorPagination();
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }

  // Reinitialize after Astro hydration
  setTimeout(init, 100);
</script>


</script>
