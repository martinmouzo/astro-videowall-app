---
// RegionAnimation.astro - Componente de animaci√≥n de regiones de Espa√±a
import "@fontsource-variable/quicksand";
---

<div id="region-animation" class="region-animation-container">
  <div class="region-header">
    <h2>Exploraci√≥n por Regiones</h2>
    <div class="animation-status">
      <span class="status-indicator"></span>
      <span class="status-text">Iniciando animaci√≥n...</span>
    </div>
  </div>

  <div class="region-map-container">
    <div id="region-map" class="region-map"></div>

    <!-- Overlay de informaci√≥n de regi√≥n -->
    <div class="region-info-overlay">
      <div class="region-name"></div>
      <div class="region-details"></div>
      <div class="centers-count"></div>
      <ul class="centers-list"></ul>
    </div>

    <!-- Controles de animaci√≥n -->
    <div class="animation-controls">
      <button class="control-btn" id="play-pause">‚è∏Ô∏è</button>
      <button class="control-btn" id="restart">üîÑ</button>
      <button class="control-btn" id="next">‚è≠Ô∏è</button>
    </div>
  </div>
</div>

<style>
  .region-animation-container {
    width: 100%;
    height: 100%;
    position: relative;
    background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  .region-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px 30px;
    background: rgba(0, 0, 0, 0.3);
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  }

  .region-header h2 {
    font-family: 'Quicksand Variable', 'Quicksand', sans-serif;
    font-weight: 700;
    font-size: 24px;
    color: #ffffff;
    margin: 0;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .animation-status {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .status-indicator {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: #4ade80;
    animation: pulse 2s infinite;
  }

  .status-text {
    font-family: 'Quicksand Variable', 'Quicksand', sans-serif;
    font-weight: 500;
    font-size: 14px;
    color: #cccccc;
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }

  .region-map-container {
    flex: 1;
    position: relative;
    overflow: hidden;
  }

  .region-map {
    width: 100%;
    height: 100%;
    position: relative;
    background: #1E1E1E;
  }

  /* Ocultar controles de MapLibre */
  :global(.maplibregl-ctrl-group),
  :global(.maplibregl-ctrl-attrib),
  :global(.maplibregl-ctrl-logo),
  :global(.maplibregl-ctrl) {
    display: none !important;
  }

  .region-info-overlay {
    position: absolute;
    top: 20px;
    left: 20px;
    background: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(10px);
    border-radius: 15px;
    padding: 20px;
    min-width: 280px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    z-index: 1000;
    opacity: 0;
    transform: translateY(-10px);
    transition: all 0.3s ease;
  }

  .region-info-overlay.visible {
    opacity: 1;
    transform: translateY(0);
  }

  .region-name {
    font-family: 'Quicksand Variable', 'Quicksand', sans-serif;
    font-weight: 700;
    font-size: 22px;
    color: #ffffff;
    margin-bottom: 10px;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .region-details {
    font-family: 'Quicksand Variable', 'Quicksand', sans-serif;
    font-weight: 500;
    font-size: 14px;
    color: #cccccc;
    margin-bottom: 15px;
    line-height: 1.5;
  }

  .centers-count {
    font-family: 'Quicksand Variable', 'Quicksand', sans-serif;
    font-weight: 600;
    font-size: 16px;
    color: #4ade80;
    background: rgba(74, 222, 128, 0.1);
    padding: 8px 12px;
    border-radius: 8px;
    border: 1px solid rgba(74, 222, 128, 0.3);
    margin-bottom: 10px;
  }

  .centers-list {
    list-style: none;
    padding: 0;
    margin: 0;
    max-height: 150px;
    overflow-y: auto;
    font-family: 'Quicksand Variable', 'Quicksand', sans-serif;
  }

  .centers-list li {
    font-size: 13px;
    color: #bbbbbb;
    padding: 6px 0;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
  }

  .centers-list li:last-child {
    border-bottom: none;
  }

  .centers-list strong {
    color: #ffffff;
    font-weight: 600;
  }

  .animation-controls {
    position: absolute;
    bottom: 20px;
    right: 20px;
    display: flex;
    gap: 10px;
    z-index: 1000;
  }

  .control-btn {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    border: none;
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(10px);
    color: #ffffff;
    font-size: 20px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 1px solid rgba(255, 255, 255, 0.2);
  }

  .control-btn:hover {
    background: rgba(255, 255, 255, 0.1);
    transform: scale(1.1);
  }

  .control-btn:active {
    transform: scale(0.95);
  }

  /* Estilos para pins de regi√≥n */
  :global(.region-center-pin) {
    position: absolute;
    pointer-events: auto;
    z-index: 999;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: radial-gradient(circle, #4ade80, #22c55e);
    border: 2px solid rgba(255, 255, 255, 0.8);
    box-shadow: 0 4px 12px rgba(74, 222, 128, 0.4);
    transform: translate(-50%, -50%);
    cursor: pointer;
    transition: all 0.3s ease;
    animation: pulsePin 2s infinite;
  }

  :global(.region-center-pin:hover) {
    transform: translate(-50%, -50%) scale(1.2);
    box-shadow: 0 6px 16px rgba(74, 222, 128, 0.6);
  }

  :global(.region-center-pin.highlighted) {
    background: radial-gradient(circle, #fbbf24, #f59e0b);
    border-color: #fbbf24;
    box-shadow: 0 6px 20px rgba(251, 191, 36, 0.6);
    animation: highlightPulse 1.5s infinite;
  }

  @keyframes pulsePin {
    0%, 100% {
      box-shadow: 0 4px 12px rgba(74, 222, 128, 0.4);
    }
    50% {
      box-shadow: 0 4px 12px rgba(74, 222, 128, 0.8);
    }
  }

  @keyframes highlightPulse {
    0%, 100% {
      box-shadow: 0 6px 20px rgba(251, 191, 36, 0.6);
      transform: translate(-50%, -50%) scale(1.2);
    }
    50% {
      box-shadow: 0 8px 24px rgba(251, 191, 36, 1);
      transform: translate(-50%, -50%) scale(1.3);
    }
  }

  /* Efecto de zoom de regi√≥n */
  .region-map.zooming {
    transition: all 2s ease-in-out;
  }

  /* Responsivo */
  @media (max-width: 768px) {
    .region-header {
      padding: 15px 20px;
    }

    .region-header h2 {
      font-size: 20px;
    }

    .region-info-overlay {
      top: 15px;
      left: 15px;
      right: 15px;
      min-width: auto;
      padding: 15px;
    }

    .animation-controls {
      bottom: 15px;
      right: 15px;
    }

    .control-btn {
      width: 45px;
      height: 45px;
      font-size: 18px;
    }
  }
</style>

<script>
  import maplibregl from 'maplibre-gl';
  import 'maplibre-gl/dist/maplibre-gl.css';
  import { gsap } from 'gsap';
  import { spainConfig } from '../mocks/data/spain-locations';

  let regionMap: maplibregl.Map;
  let regionMarkers: maplibregl.Marker[] = [];
  let currentRegionIndex = 0;
  let isAnimating = false;
  let animationTimer: NodeJS.Timeout | null = null;

  // Definici√≥n de regiones l√≥gicas de Espa√±a basadas en ubicaciones reales de Inditex
  const spainRegions = [
    {
      name: 'Noroeste',
      description: 'Galicia - Sede Central y Distribuci√≥n Atl√°ntica',
      bounds: [[-9.0, 43.0], [-7.5, 44.0]] as [[number, number], [number, number]],
      zoom: 8,
      centers: ['arteixo-central', 'laracha-cpd2-node', 'naron-node'],
      color: '#4ade80'
    },
    {
      name: 'Norte-Centro',
      description: 'Castilla y Le√≥n - Distribuci√≥n Norte',
      bounds: [[-6.5, 42.0], [-4.5, 43.5]] as [[number, number], [number, number]],
      zoom: 8,
      centers: ['leon-node'],
      color: '#3b82f6'
    },
    {
      name: 'Nordeste',
      description: 'Catalu√±a y Arag√≥n - Hub Industrial y Log√≠stico',
      bounds: [[-1.5, 41.0], [3.5, 42.5]] as [[number, number], [number, number]],
      zoom: 7,
      centers: ['sallent-node', 'tordera-node', 'zaragoza-node'],
      color: '#8b5cf6'
    },
    {
      name: 'Centro',
      description: 'Madrid, Guadalajara y Toledo - Hub Central de Distribuci√≥n',
      bounds: [[-4.5, 39.5], [-2.5, 41.0]] as [[number, number], [number, number]],
      zoom: 7.5,
      centers: ['meco-node', 'cabanillas-node', 'marchamalo-node', 'toledo-node', 'illescas-node'],
      color: '#f59e0b'
    },
    {
      name: 'Sureste',
      description: 'Alicante - Centro Industrial del Calzado',
      bounds: [[-1.5, 37.5], [0.5, 39.0]] as [[number, number], [number, number]],
      zoom: 8.5,
      centers: ['elche-node'],
      color: '#ef4444'
    }
  ];

  // Configuraci√≥n del mapa de regiones
  const regionMapConfig = {
    container: 'region-map',
    style: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json', // URL del estilo Dark Matter
    center: [-3.7492, 40.2637] as [number, number], // Centro de Espa√±a
    zoom: 6,
    minZoom: 5,
    maxZoom: 12,
    pitch: 0,
    bearing: 0,
    interactive: true,
    scrollZoom: true,
    boxZoom: false,
    dragRotate: false,
    dragPan: true,
    keyboard: false,
    doubleClickZoom: true,
    touchZoomRotate: false,
    preserveDrawingBuffer: true,
    antialias: true
  };

  function initializeRegionMap() {
    try {
      regionMap = new maplibregl.Map(regionMapConfig);

      regionMap.on('load', () => {
        console.log('üó∫Ô∏è Mapa de regiones cargado con Dark Matter GL Style');

        // ---- START: MODIFICATIONS FOR COLOR MATCHING AND MINIMALIST STYLE ----
        const style = regionMap.getStyle();
        if (!style || !style.layers) {
          console.error('Estilo de mapa no disponible para modificar.');
          return;
        }

        // Target colors from SpainMap.astro
        const targetBackgroundColor = '#525252'; // Updated
        const targetWaterColor = '#1A1A1A';    // Updated
        const targetLandColor = '#525252';      // Updated

        // Patterns for layers to hide for a minimalist, flat look
        // Order matters if a layer could match multiple patterns
        const hidePatterns = [
          'road',       // roads, roadname_*
          'tunnel',
          'bridge',
          'aeroway',
          'building',
          'poi',        // Points of Interest labels and icons
          'housenumber',
          'boundary_',  // Admin boundaries (county, state, country lines)
          'residential',// e.g., landuse_residential
          'waterway',   // River/stream lines. Also hides waterway_label if not caught by a more specific rule.
          'transit',    // Transit lines/labels if any
          'ferry',      // Ferry routes
          // Specific Dark Matter layers that might add too much detail or are not place labels
          'building-extrusion',
          'hillshade',
          'landuse_overlay',
          'contour',
          'watername', // Explicitly hide water names (watername_ocean, watername_sea, watername_lake)
          'waterway_label', // Explicitly hide waterway labels
          'park',       // Hides park_national_park, park_nature_reserve etc.
          'landuse'     // Hides landuse (cemetery, stadium etc. from Dark Matter). landuse_residential is covered by 'residential'.
          // Add other specific non-place labels if they appear
        ];

        // Patterns for layers to ALWAYS SHOW (these are exceptions to hidePatterns)
        const showPatterns = [
          'place_', // place_hamlet, place_suburb, place_village, place_town, place_city_*, place_capital_*
        ];


        style.layers.forEach(layer => {
          const layerId = layer.id.toLowerCase(); // Work with lowercase for consistency
          let forceShow = false; // Renamed from —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ–ü–æ–∫–∞–∑–∞—Ç—å

          // Check if layer should be specifically shown (overrides hiding)
          for (const pattern of showPatterns) {
            if (layerId.includes(pattern)) {
              forceShow = true;
              // console.log(`Force showing layer: ${layer.id}`);
              break;
            }
          }

          if (!forceShow) {
            let isHidden = false;
            // Check if layer should be hidden
            for (const pattern of hidePatterns) {
              if (layerId.includes(pattern)) {
                if (regionMap.getLayer(layer.id)) {
                  try {
                    regionMap.setLayoutProperty(layer.id, 'visibility', 'none');
                    // console.log(`Hid layer: ${layer.id}`);
                    isHidden = true;
                  } catch (e) {
                    // console.warn(`Could not hide layer ${layer.id}: ${e.message}`);
                  }
                }
                break;
              }
            }
            if (isHidden) return; // Skip color changes if hidden by general rules and not force-shown
          } else {
             // If specifically shown, ensure visibility is set to 'visible' in case a broader rule tried to hide it
             const currentLayer = regionMap.getLayer(layer.id);
             if (currentLayer) {
                try {
                    // Check current visibility, only set if it's 'none'
                    const currentVisibility = regionMap.getLayoutProperty(layer.id, 'visibility');
                    if (currentVisibility === 'none') {
                        regionMap.setLayoutProperty(layer.id, 'visibility', 'visible');
                        // console.log(`Ensured layer is visible: ${layer.id}`);
                    }
                } catch (e) {
                    // console.warn(`Could not ensure visibility for layer ${layer.id}: ${e.message}`);
                }
            }
          }

          // Apply color changes to visible layers
          try {
            if (layer.id === 'background') { // Exact ID match
              if (regionMap.getPaintProperty(layer.id, 'background-color')) {
                regionMap.setPaintProperty(layer.id, 'background-color', targetBackgroundColor);
              }
            } else if (layer.id === 'water') { // Exact ID match for main water bodies
              if (regionMap.getPaintProperty(layer.id, 'fill-color')) {
                regionMap.setPaintProperty(layer.id, 'fill-color', targetWaterColor);
              }
              if (regionMap.getPaintProperty(layer.id, 'fill-outline-color')) {
                 regionMap.setPaintProperty(layer.id, 'fill-outline-color', 'transparent');
              }
            } else if (layerId.includes('landcover') || layerId.includes('earth')) {
              // This primarily targets base land layers like 'landcover', 'earth'
              // Assumes more specific land markings (park, landuse categories) are hidden by hidePatterns
              // Avoid changing colors of layers that are meant to be shown (place labels) if they are fill types.
              const layerToStyle = regionMap.getLayer(layer.id);
              if (layerToStyle && layerToStyle.type === 'fill' && !forceShow) {
                if (regionMap.getPaintProperty(layer.id, 'fill-color')) {
                  regionMap.setPaintProperty(layer.id, 'fill-color', targetLandColor);
                }
                if (regionMap.getPaintProperty(layer.id, 'fill-outline-color')) {
                  regionMap.setPaintProperty(layer.id, 'fill-outline-color', 'transparent');
                }
              }
            }
          } catch (e) {
            // console.warn(`Could not set paint property for layer ${layer.id}: ${e.message}`);
          }
        });
        console.log('üó∫Ô∏è Mapa de regiones: Dark Matter GL Style colors and visibility adjusted.');
        // ---- END: MODIFICATIONS ----


        // Iniciar animaci√≥n autom√°tica
        setTimeout(() => {
          startRegionAnimation();
        }, 1000);
      });

      regionMap.on('error', (e) => {
        console.error('Error en el mapa de regiones:', e);
      });

    } catch (error) {
      console.error('Error inicializando el mapa de regiones:', error);
    }
  }

  function highlightSpain() {
    // Esta funci√≥n ya no es necesaria con un estilo GL completo como Dark Matter.
    // El estilo en s√≠ deber√≠a manejar la diferenciaci√≥n de caracter√≠sticas geogr√°ficas.
    console.log('‚ÑπÔ∏è Usando Dark Matter GL Style. La funci√≥n highlightSpain no se aplica de la misma manera.');
  }

  function clearAllPins() {
    // Limpiar todos los pins existentes
    regionMarkers.forEach(marker => {
      marker.remove();
    });
    regionMarkers = [];
    console.log('üßπ Todos los pins limpiados');
  }

  function createRegionPins(centerIds: string[]) {
    // Limpiar pins existentes
    clearAllPins();

    console.log(`üìç Creando pins para regi√≥n con centros: ${centerIds.join(', ')}`);

    // Crear pin central de Arteixo siempre
    if (centerIds.includes('arteixo-central') || centerIds.includes('laracha-cpd2-node') || centerIds.includes('naron-node')) {
      createRegionPin(spainConfig.centralNode, true);
    }

    // Crear pins para ubicaciones de esta regi√≥n
    centerIds.forEach(centerId => {
      const node = spainConfig.remoteNodes.find(n => n.id === centerId || n.name === centerId);
      if (node) {
        createRegionPin(node, false);
      }
    });

    updateStatusText(`${regionMarkers.length} centros cargados en regi√≥n`);
  }

  function createRegionPin(node: any, isCentral: boolean = false) {
    if (!node.coordinates || node.coordinates.length !== 2) {
      console.error(`‚ùå Coordenadas inv√°lidas para ${node.name}:`, node.coordinates);
      return;
    }

    const pin = document.createElement('div');
    pin.className = isCentral ? 'region-center-pin central' : 'region-center-pin';
    pin.setAttribute('data-center-id', node.id || node.name);
    pin.setAttribute('data-center-name', node.name);

    // Agregar informaci√≥n del centro en el tooltip
    pin.title = `${node.name} - ${node.city || ''}`;

    try {
      const marker = new maplibregl.Marker({
        element: pin,
        anchor: 'center'
      })
      .setLngLat(node.coordinates)
      .addTo(regionMap);

      regionMarkers.push(marker);
      console.log(`‚úÖ Pin de regi√≥n creado para ${node.name}`);

      // Agregar evento de click
      pin.addEventListener('click', () => {
        focusOnCenter(node);
      });

    } catch (error) {
      console.error(`‚ùå Error creando pin de regi√≥n para ${node.name}:`, error);
    }
  }

  function startRegionAnimation() {
    if (isAnimating) return;

    isAnimating = true;
    currentRegionIndex = 0;
    updateStatusText('Animaci√≥n iniciada');

    animateToNextRegion();
  }

  function animateToNextRegion() {
    if (!isAnimating || currentRegionIndex >= spainRegions.length) {
      // Reiniciar la animaci√≥n al final
      currentRegionIndex = 0;
      setTimeout(() => {
        if (isAnimating) animateToNextRegion();
      }, 3000);
      return;
    }

    const region = spainRegions[currentRegionIndex];
    console.log(`üéØ Animando hacia regi√≥n: ${region.name}`);

    // Actualizar informaci√≥n de la regi√≥n
    updateRegionInfo(region);

    // Crear pins solo para esta regi√≥n
    createRegionPins(region.centers);

    // Animar el mapa hacia la regi√≥n
    const bounds = new maplibregl.LngLatBounds(region.bounds[0], region.bounds[1]);

    regionMap.fitBounds(bounds, {
      padding: { top: 50, bottom: 50, left: 50, right: 50 },
      duration: 2000,
      zoom: region.zoom
    });

    updateStatusText(`Explorando ${region.name}`);

    // Programar siguiente regi√≥n
    animationTimer = setTimeout(() => {
      currentRegionIndex++;
      animateToNextRegion();
    }, 6000); // 6 segundos por regi√≥n
  }

  function updateRegionInfo(region: any) {
    const overlay = document.querySelector('.region-info-overlay') as HTMLElement;
    if (!overlay) return;

    const nameEl = overlay.querySelector('.region-name') as HTMLElement;
    const detailsEl = overlay.querySelector('.region-details') as HTMLElement;
    const countEl = overlay.querySelector('.centers-count') as HTMLElement;
    const centersListEl = overlay.querySelector('.centers-list') as HTMLUListElement;

    if (nameEl) nameEl.textContent = region.name;
    if (detailsEl) detailsEl.textContent = region.description;
    if (countEl) countEl.textContent = `${region.centers.length} centros en esta regi√≥n`;

    if (centersListEl) {
      centersListEl.innerHTML = ''; // Clear previous items

      region.centers.forEach((centerId: string) => {
        let node = spainConfig.remoteNodes.find(n => n.id === centerId);
        if (!node && spainConfig.centralNode.id === centerId) {
          node = spainConfig.centralNode;
        }

        if (node) {
          const listItem = document.createElement('li');
          listItem.innerHTML = `<strong>${node.name}</strong> (${node.city || 'N/A'})`;
          centersListEl.appendChild(listItem);
        }
      });
    }

    // Animar la aparici√≥n
    overlay.classList.add('visible');

    gsap.fromTo(overlay,
      { scale: 0.9, opacity: 0 },
      { scale: 1, opacity: 1, duration: 0.5, ease: "back.out(1.2)" }
    );
  }

  function highlightRegionCenters(centerIds: string[]) {
    // Esta funci√≥n ya no es necesaria ya que creamos los pins din√°micamente
    console.log(`üéØ Pins creados din√°micamente para: ${centerIds.join(', ')}`);
  }

  function updateStatusText(text: string) {
    const statusText = document.querySelector('.status-text') as HTMLElement;
    if (statusText) {
      statusText.textContent = text;
    }
  }

  function focusOnCenter(node: any) {
    console.log(`üîç Enfocando en centro: ${node.name}`);

    regionMap.flyTo({
      center: node.coordinates,
      zoom: 10,
      duration: 1500
    });

    updateStatusText(`Enfocado en ${node.name}`);
  }

  function pauseAnimation() {
    isAnimating = false;
    if (animationTimer) {
      clearTimeout(animationTimer);
      animationTimer = null;
    }
    updateStatusText('Animaci√≥n pausada');
  }

  function resumeAnimation() {
    if (!isAnimating) {
      startRegionAnimation();
    }
  }

  function restartAnimation() {
    pauseAnimation();
    currentRegionIndex = 0;

    // Limpiar todos los pins
    clearAllPins();

    // Volver a la vista general de Espa√±a
    regionMap.flyTo({
      center: [-3.7492, 40.2637],
      zoom: 6,
      duration: 1500
    });

    setTimeout(() => {
      startRegionAnimation();
    }, 2000);
  }

  function nextRegion() {
    if (animationTimer) {
      clearTimeout(animationTimer);
    }
    currentRegionIndex++;
    if (currentRegionIndex >= spainRegions.length) {
      currentRegionIndex = 0;
    }
    animateToNextRegion();
  }

  // Inicializar cuando el DOM est√© listo
  document.addEventListener('DOMContentLoaded', () => {
    initializeRegionMap();

    // Configurar controles
    const playPauseBtn = document.getElementById('play-pause');
    const restartBtn = document.getElementById('restart');
    const nextBtn = document.getElementById('next');

    playPauseBtn?.addEventListener('click', () => {
      if (isAnimating) {
        pauseAnimation();
        playPauseBtn.textContent = '‚ñ∂Ô∏è';
      } else {
        resumeAnimation();
        playPauseBtn.textContent = '‚è∏Ô∏è';
      }
    });

    restartBtn?.addEventListener('click', restartAnimation);
    nextBtn?.addEventListener('click', nextRegion);
  });

  // Funciones globales para debugging
  (window as any).regionAnimationUtils = {
    getRegionMap: () => regionMap,
    getRegions: () => spainRegions,
    getCurrentRegion: () => spainRegions[currentRegionIndex],
    getMarkers: () => regionMarkers,
    pauseAnimation,
    resumeAnimation,
    restartAnimation,
    nextRegion,
    isAnimating: () => isAnimating,
    debugRegionAnimation: () => {
      console.log('=== DEBUG REGION ANIMATION ===');
      console.log('Map loaded:', regionMap ? regionMap.loaded() : 'Not initialized');
      console.log('Total markers:', regionMarkers.length);
      console.log('Current region index:', currentRegionIndex);
      console.log('Is animating:', isAnimating);
      console.log('Regions defined:', spainRegions.length);
    }
  };
</script>
