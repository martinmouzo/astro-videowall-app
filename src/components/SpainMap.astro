---
// SpainMap.astro - Componente simplificado de mapa de Espa√±a con sistema de conectores inteligentes
import "@fontsource-variable/quicksand";
import { spainConfig } from '../mocks/data/spain-locations';
---

<div id="spain-map" class="spain-map-container">
  <svg class="pin-connector-system" id="pin-connectors">
  </svg>
</div>

<style>
  .spain-map-container {
    width: 100%;
    height: 100%;
    position: relative;
    background: #1E1E1E;
    overflow: hidden;
  }

  /* Ocultar controles de MapLibre */
  :global(.maplibregl-ctrl-group),
  :global(.maplibregl-ctrl-attrib),
  :global(.maplibregl-ctrl-logo),
  :global(.maplibregl-ctrl) {
    display: none !important;
  }

  /* Pin central de Arteixo */
  :global(.arteixo-central-pin) {
    position: absolute;
    pointer-events: none;
    z-index: 1001;
    transform: translate(-50%, -50%);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  :global(.arteixo-central-pin .pin-content) {
    font-family: 'Quicksand Variable', 'Quicksand', sans-serif;
    font-weight: 700;
    font-size: 13px;
    color: #ffffff;
    text-transform: uppercase;
    letter-spacing: 1px;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
    background: linear-gradient(135deg, #5D5D5D, rgba(93, 93, 93, 0.8));
    backdrop-filter: blur(6px);
    padding: 6px 12px;
    border-radius: 12px;
    border: 2px solid rgba(93, 93, 93, 0.4);
    white-space: nowrap;
    box-shadow: 0 4px 16px rgba(93, 93, 93, 0.3);
  }

  /* Pins de centros regionales - estructura simplificada */
  :global(.region-center-pin) {
    position: absolute;
    pointer-events: auto;
    z-index: 1000;
    transform: translateX(-50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    cursor: pointer;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    border: 2px solid rgba(255, 255, 255, 0.8);
    transition: all 0.3s ease;
  }

  /* Colores de pin por estado de latencia */
  :global(.region-center-pin.excellent) {
    background: linear-gradient(135deg, #10b981, #059669);
    box-shadow:
      0 0 0 4px rgba(16, 185, 129, 0.3),
      0 4px 12px rgba(16, 185, 129, 0.4);
  }

  :global(.region-center-pin.good) {
    background: linear-gradient(135deg, #4ade80, #22c55e);
    box-shadow:
      0 0 0 4px rgba(74, 222, 128, 0.3),
      0 4px 12px rgba(74, 222, 128, 0.4);
  }

  :global(.region-center-pin.warning) {
    background: linear-gradient(135deg, #fbbf24, #f59e0b);
    box-shadow:
      0 0 0 4px rgba(251, 191, 36, 0.3),
      0 4px 12px rgba(251, 191, 36, 0.4);
  }

  :global(.region-center-pin.critical) {
    background: linear-gradient(135deg, #ef4444, #dc2626);
    box-shadow:
      0 0 0 4px rgba(239, 68, 68, 0.3),
      0 4px 12px rgba(239, 68, 68, 0.4);
  }

  :global(.region-center-pin:hover) {
    transform: translateX(-50%) scale(1.2);
    box-shadow:
      0 0 0 8px rgba(74, 222, 128, 0.5),
      0 8px 20px rgba(0, 0, 0, 0.6);
  }

  /* Sistema de conectores SVG para labels */
  :global(.pin-connector-system) {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1002;
    overflow: visible;
  }

  :global(.pin-connector-line) {
    stroke-width: 1.5;
    stroke-dasharray: 3,2;
    opacity: 0.7;
    transition: all 0.3s ease;
    fill: none;
  }

  /* L√≠neas conectoras con colores por latencia */
  :global(.pin-connector-line.excellent) {
    stroke: #10b981;
  }

  :global(.pin-connector-line.good) {
    stroke: #4ade80;
  }

  :global(.pin-connector-line.warning) {
    stroke: #fbbf24;
  }

  :global(.pin-connector-line.critical) {
    stroke: #ef4444;
  }

  /* Labels conectadas con posicionamiento inteligente */
  :global(.pin-label-connected) {
    position: absolute;
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.96), rgba(20, 20, 20, 0.98));
    backdrop-filter: blur(18px);
    border-radius: 10px;
    padding: 7px 14px;
    font-family: 'Quicksand Variable', 'Quicksand', sans-serif;
    font-weight: 700;
    font-size: 11px;
    white-space: nowrap;
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow:
      0 8px 25px rgba(0, 0, 0, 0.8),
      0 2px 10px rgba(0, 0, 0, 0.6);
    z-index: 1003;
    pointer-events: none;
    opacity: 0.97;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    min-width: 85px;
    text-align: center;
    letter-spacing: 0.3px;
  }

  /* Labels con colores por estado de latencia */
  :global(.pin-label-connected.excellent) {
    color: #10b981;
    border-color: rgba(16, 185, 129, 0.4);
    box-shadow: 0 4px 16px rgba(16, 185, 129, 0.2);
  }

  :global(.pin-label-connected.good) {
    color: #4ade80;
    border-color: rgba(74, 222, 128, 0.4);
    box-shadow: 0 4px 16px rgba(74, 222, 128, 0.2);
  }

  :global(.pin-label-connected.warning) {
    color: #fbbf24;
    border-color: rgba(251, 191, 36, 0.4);
    box-shadow: 0 4px 16px rgba(251, 191, 36, 0.2);
  }

  :global(.pin-label-connected.critical) {
    color: #ef4444;
    border-color: rgba(239, 68, 68, 0.4);
    box-shadow: 0 4px 16px rgba(239, 68, 68, 0.2);
  }

  /* Efectos hover para pins conectados */
  :global(.region-center-pin:hover) + :global(.pin-connector-line) {
    stroke-width: 2;
    opacity: 1;
  }

  :global(.region-center-pin:hover) + :global(.pin-label-connected) {
    opacity: 1;
    transform: scale(1.05);
  }
</style>

<script>
  import maplibregl from 'maplibre-gl';
  import 'maplibre-gl/dist/maplibre-gl.css';
  import { spainConfig, spainMapData, locationDetails, getLatencyClass } from '../mocks/data/spain-locations';
  import type { LngLatLike, StyleSpecification, ExpressionSpecification } from 'maplibre-gl';

  let map: maplibregl.Map;
  let markers: maplibregl.Marker[] = [];

  // Configuraci√≥n simplificada del mapa de Espa√±a
  const spainMapConfig = {
    container: 'spain-map',
    style: {
      version: 8,
      sources: {
        'countries': {
          type: 'vector',
          tiles: [
            'https://demotiles.maplibre.org/tiles/{z}/{x}/{y}.pbf'
          ],
          minzoom: 0,
          maxzoom: 14
        }
      },
      layers: [
        {
          id: 'background',
          type: 'background',
          paint: {
            'background-color': '#1a1a1a'
          }
        },
        {
          id: 'countries-base',
          type: 'fill',
          source: 'countries',
          'source-layer': 'countries',
          paint: {
            'fill-color': '#2A2A2A',
            'fill-opacity': 0.8,
            'fill-outline-color': 'rgba(0,0,0,0)',
            'fill-antialias': false
          }
        }
      ]
    } as StyleSpecification,
    center: spainMapData.center as LngLatLike,
    zoom: spainMapData.zoom.initial,
    minZoom: spainMapData.zoom.min,
    maxZoom: spainMapData.zoom.max,
    pitch: 0,
    bearing: 0,
    interactive: false, // Mapa est√°tico
    scrollZoom: false,
    boxZoom: false,
    dragRotate: false,
    dragPan: false,
    keyboard: false,
    doubleClickZoom: false,
    touchZoomRotate: false,
    preserveDrawingBuffer: true,
    antialias: true
  };

  function initializeSpainMap() {
    try {
      map = new maplibregl.Map(spainMapConfig);

      map.on('load', () => {
        console.log('üá™üá∏ Mapa est√°tico de Espa√±a cargado');

        // Colorear Espa√±a
        addSpainColors();

        // Crear pins de todas las ubicaciones
        createAllLocationPins();

        // Recalcular conectores despu√©s de que todo est√© cargado
        setTimeout(() => {
          updateAllConnectors();
        }, 500);
      });

      map.on('resize', () => {
        // Recalcular posiciones de conectores cuando cambie el tama√±o
        setTimeout(() => {
          updateAllConnectors();
        }, 100);
      });

      map.on('error', (e) => {
        console.error('Error en el mapa de Espa√±a:', e);
        setTimeout(() => {
          if (!map.loaded()) {
            initializeSpainMap();
          }
        }, 2000);
      });

      return map;
    } catch (error) {
      console.error('Error inicializando el mapa de Espa√±a:', error);
      setTimeout(initializeSpainMap, 2000);
    }
  }

  function addSpainColors() {
    // Destacar Espa√±a en color gris, resto del mapa en gris m√°s oscuro
    const expression: ExpressionSpecification = [
      'case',
      ['==', ['get', 'NAME'], 'Spain'], '#5D5D5D',
      ['==', ['get', 'name'], 'Spain'], '#5D5D5D',
      ['==', ['get', 'iso_a2'], 'ES'], '#5D5D5D',
      '#2A2A2A'
    ];

    try {
      map.addLayer({
        id: 'spain-highlighted',
        type: 'fill',
        source: 'countries',
        'source-layer': 'countries',
        paint: {
          'fill-color': expression,
          'fill-opacity': 0.8,
          'fill-outline-color': 'transparent'
        }
      });
      console.log('‚úÖ Espa√±a destacada en el mapa');
    } catch (error) {
      console.error('‚ùå Error destacando Espa√±a:', error);
    }
  }

  function createAllLocationPins() {
    console.log('üìç Creando pins para todas las ubicaciones...');

    // Crear pin central de Arteixo
    createCentralPin();

    // Crear pins para todas las ubicaciones remotas como region-center-pin
    spainConfig.remoteNodes.forEach((node) => {
      createRegionCenterPin(node);
    });
  }

  function createCentralPin() {
    const centralNode = spainConfig.centralNode;
    console.log('üè¢ Creando pin central de Arteixo:', centralNode.coordinates);

    if (!centralNode.coordinates || centralNode.coordinates.length !== 2) {
      console.error('‚ùå Coordenadas de Arteixo inv√°lidas:', centralNode.coordinates);
      return;
    }

    const centralContainer = document.createElement('div');
    centralContainer.className = 'arteixo-central-pin';
    centralContainer.innerHTML = `
      <span class="pin-content">${centralNode.name}</span>
    `;

    const marker = new maplibregl.Marker({
      element: centralContainer,
      anchor: 'center'
    })
    .setLngLat(centralNode.coordinates)
    .addTo(map);

    markers.push(marker);
    console.log('‚úÖ Pin central de Arteixo creado');
  }

  function createRegionCenterPin(node: any) {
    console.log(`üìç Creando region-center-pin con conector para ${node.name}`, {
      id: node.id,
      coordinates: node.coordinates,
      latency: node.latency
    });

    if (!node.coordinates || node.coordinates.length !== 2) {
      console.error(`‚ùå Coordenadas inv√°lidas para ${node.name}:`, node.coordinates);
      return;
    }

    // Usar la latencia real del nodo
    const latency = node.latency;
    const latencyClass = getLatencyClass(latency);

    // Crear pin simplificado (solo el c√≠rculo)
    const pin = document.createElement('div');
    pin.className = `region-center-pin ${latencyClass}`;
    pin.setAttribute('data-node-id', node.id);
    pin.setAttribute('data-latency', latency.toString());

    try {
      const marker = new maplibregl.Marker({
        element: pin,
        anchor: 'center'
      })
      .setLngLat(node.coordinates)
      .addTo(map);

      markers.push(marker);

      // Crear conector y label despu√©s de que el pin est√© en el DOM
      setTimeout(() => {
        createPinConnector(node, pin, latencyClass);
      }, 100);

      console.log(`‚úÖ Region-center-pin con conector creado para ${node.name} (${latencyClass})`);
    } catch (error) {
      console.error(`‚ùå Error creando region-center-pin para ${node.name}:`, error);
    }
  }

  // Nueva funci√≥n para crear conectores inteligentes
  function createPinConnector(node: any, pinElement: HTMLElement, latencyClass: string) {
    const mapContainer = document.getElementById('spain-map');
    const svgContainer = document.getElementById('pin-connectors');

    if (!mapContainer || !svgContainer) {
      console.error('‚ùå No se encontraron contenedores para conectores');
      return;
    }

    // Obtener posici√≥n del pin en el mapa
    const pinRect = pinElement.getBoundingClientRect();
    const mapRect = mapContainer.getBoundingClientRect();

    const pinX = pinRect.left - mapRect.left + pinRect.width / 2;
    const pinY = pinRect.top - mapRect.top + pinRect.height / 2;

    // Determinar posici√≥n √≥ptima para la label (evitar solapamientos)
    const labelPosition = calculateOptimalLabelPosition(pinX, pinY, node.name);

    // Crear l√≠nea conectora SVG
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', pinX.toString());
    line.setAttribute('y1', pinY.toString());
    line.setAttribute('x2', labelPosition.x.toString());
    line.setAttribute('y2', labelPosition.y.toString());
    line.setAttribute('class', `pin-connector-line ${latencyClass}`);

    svgContainer.appendChild(line);

    // Crear label conectada
    const label = document.createElement('div');
    label.className = `pin-label-connected ${latencyClass}`;
    label.style.left = `${labelPosition.x}px`;
    label.style.top = `${labelPosition.y}px`;
    label.style.transform = 'translate(-50%, -50%)';

    // Usar el nombre exacto del nodo
    label.textContent = `${node.name} ‚Ä¢ ${node.latency}ms`;

    mapContainer.appendChild(label);

    console.log(`‚úÖ Conector creado para ${node.name} en posici√≥n ${labelPosition.direction}`);
  }

  // Algoritmo de posicionamiento inteligente para evitar solapamientos
  function calculateOptimalLabelPosition(pinX: number, pinY: number, nodeName: string) {
    const mapContainer = document.getElementById('spain-map');
    if (!mapContainer) return { x: pinX, y: pinY, direction: 'top' };

    const mapRect = mapContainer.getBoundingClientRect();
    const mapWidth = mapRect.width;
    const mapHeight = mapRect.height;

    // Distancia del conector (radio) - reducida para mayor cercan√≠a
    let connectorLength = 35;

    // Distancias reducidas para la regi√≥n Centro manteniendo separaci√≥n
    if (nodeName.includes('Meco') || nodeName.includes('Cabanillas') ||
        nodeName.includes('March√°malo') || nodeName.includes('Toledo') ||
        nodeName.includes('Illescas')) {
      connectorLength = 65; // Distancia reducida para regi√≥n Centro
      console.log(`üéØ Usando conector reducido (65px) para regi√≥n Centro: ${nodeName}`);
    }

    // Posiciones candidatas (8 direcciones para mejor distribuci√≥n)
    const positions = [
      {
        x: pinX,
        y: pinY - connectorLength,
        direction: 'top',
        priority: pinY > connectorLength + 30 ? 1 : 4
      },
      {
        x: pinX,
        y: pinY + connectorLength,
        direction: 'bottom',
        priority: pinY < mapHeight - connectorLength - 30 ? 2 : 4
      },
      {
        x: pinX + connectorLength,
        y: pinY,
        direction: 'right',
        priority: pinX < mapWidth - connectorLength - 80 ? 2 : 4
      },
      {
        x: pinX - connectorLength,
        y: pinY,
        direction: 'left',
        priority: pinX > connectorLength + 80 ? 3 : 4
      },
      {
        x: pinX + connectorLength * 0.85,
        y: pinY - connectorLength * 0.85,
        direction: 'top-right',
        priority: 3
      },
      {
        x: pinX - connectorLength * 0.85,
        y: pinY - connectorLength * 0.85,
        direction: 'top-left',
        priority: 3
      },
      {
        x: pinX + connectorLength * 0.85,
        y: pinY + connectorLength * 0.85,
        direction: 'bottom-right',
        priority: 3
      },
      {
        x: pinX - connectorLength * 0.85,
        y: pinY + connectorLength * 0.85,
        direction: 'bottom-left',
        priority: 3
      }
    ];

    // Sistema de posicionamiento determinista por ubicaci√≥n espec√≠fica
    // Distribuci√≥n optimizada para la regi√≥n Centro seg√∫n especificaciones exactas

    // Sistema de posicionamiento triangular para March√°malo, Meco y Cabanillas
    // Distribuci√≥n espec√≠fica en forma de tri√°ngulo equil√°tero

    // Regi√≥n Centro - Distribuci√≥n triangular para las 3 ubicaciones principales
    if (nodeName.includes('March√°malo')) {
      // March√°malo - V√©rtice superior del tri√°ngulo (arriba)
      const triangleDistance = connectorLength * 1.5;
      const trianglePosition = {
        x: pinX,
        y: pinY - triangleDistance,
        direction: 'triangle-top',
        priority: 1
      };
      console.log(`üî∫ Posicionando ${nodeName} en V√âRTICE SUPERIOR del tri√°ngulo (${triangleDistance}px)`);
      return trianglePosition;
    }
    else if (nodeName.includes('Meco')) {
      // Meco - V√©rtice inferior derecho del tri√°ngulo
      const triangleDistance = connectorLength * 1.5;
      const triangleX = pinX + (triangleDistance * 0.866); // cos(30¬∞) ‚âà 0.866
      const triangleY = pinY + (triangleDistance * 0.5);   // sin(30¬∞) = 0.5
      const trianglePosition = {
        x: triangleX,
        y: triangleY,
        direction: 'triangle-bottom-right',
        priority: 1
      };
      console.log(`üî∫ Posicionando ${nodeName} en V√âRTICE INFERIOR DERECHO del tri√°ngulo (${triangleDistance}px)`);
      return trianglePosition;
    }
    else if (nodeName.includes('Cabanillas')) {
      // Cabanillas - V√©rtice izquierdo del tri√°ngulo (movido hacia el norte)
      const triangleDistance = connectorLength * 1.5;
      const triangleX = pinX - (triangleDistance * 0.866); // cos(30¬∞) ‚âà 0.866
      const triangleY = pinY - (triangleDistance * 0.2);   // Movido hacia el norte para evitar solapamiento con Illescas
      const trianglePosition = {
        x: triangleX,
        y: triangleY,
        direction: 'triangle-left-north',
        priority: 1
      };
      console.log(`üî∫ Posicionando ${nodeName} en V√âRTICE IZQUIERDO-NORTE del tri√°ngulo (${triangleDistance}px) - evitando Illescas`);
      return trianglePosition;
    }
    // Otras ubicaciones del Centro con posicionamiento geogr√°fico
    else if (nodeName.includes('Toledo') || nodeName.includes('Illescas')) {
      // Obtener las coordenadas reales del nodo
      const node = spainConfig.remoteNodes.find(n => n.name === nodeName);
      if (node && node.coordinates) {
        const [lng, lat] = node.coordinates;

        // Centro de referencia para la regi√≥n Centro (Madrid aprox)
        const centerLng = -3.7;
        const centerLat = 40.4;

        // Calcular diferencias relativas
        const deltaLng = lng - centerLng; // negativo = oeste, positivo = este
        const deltaLat = lat - centerLat;  // negativo = sur, positivo = norte

        // Factores de escala para convertir grados a p√≠xeles
        let scaleX = connectorLength * 2.0; // Factor horizontal reducido para evitar solapamiento
        let scaleY = connectorLength * 2.0; // Factor vertical reducido

        // Ajuste espec√≠fico para Illescas - posicionada a la izquierda del pin
        if (nodeName.includes('Illescas')) {
          // Posici√≥n fija a la izquierda del pin, lado opuesto
          const illescasPosition = {
            x: pinX - connectorLength * 1.2, // A la izquierda del pin con separaci√≥n
            y: pinY - connectorLength * 0.3, // Ligeramente hacia el norte
            direction: 'illescas-left-positioned',
            priority: 1
          };
          console.log(`üéØ Posicionando ${nodeName} a la IZQUIERDA del pin (lado opuesto)`);
          return illescasPosition;
        }

        // Ajuste espec√≠fico para Toledo - reducir distancia
        if (nodeName.includes('Toledo')) {
          scaleX = connectorLength * 1.4; // Reducir distancia horizontal para Toledo
          scaleY = connectorLength * 1.4; // Reducir distancia vertical para Toledo
          console.log(`üéØ Usando factores reducidos para ${nodeName}: scaleX=${scaleX}, scaleY=${scaleY}`);
        }

        // Calcular posici√≥n escalada para Toledo (mantener geogr√°fico)
        const scaledX = pinX + (deltaLng * scaleX);
        const scaledY = pinY - (deltaLat * scaleY); // Invertir Y porque en pantalla Y crece hacia abajo

        // Crear posici√≥n personalizada basada en coordenadas
        const geographicPosition = {
          x: scaledX,
          y: scaledY,
          direction: `geo-${deltaLng >= 0 ? 'east' : 'west'}-${deltaLat >= 0 ? 'north' : 'south'}`,
          priority: 1
        };

        console.log(`üó∫Ô∏è Posicionamiento geogr√°fico para ${nodeName}:`, {
          coordinates: [lng, lat],
          deltas: [deltaLng, deltaLat],
          scaledPosition: [scaledX, scaledY],
          direction: geographicPosition.direction
        });

        return geographicPosition;
      }
    }

    // Otras regiones con heur√≠sticas espec√≠ficas
    else if (nodeName.includes('Le√≥n')) {
      // Le√≥n - Norte-centro, posici√≥n izquierda
      positions[3].priority = 1; // left
      positions[5].priority = 2; // top-left
    }
    else if (nodeName.includes('Zaragoza')) {
      // Zaragoza - Nordeste, posici√≥n superior
      positions[0].priority = 1; // top
      positions[4].priority = 2; // top-right
    }
    else if (nodeName.includes('Sallent')) {
      // Barcelona/Sallent - Nordeste, posici√≥n izquierda
      positions[3].priority = 1; // left
      positions[5].priority = 2; // top-left
    }
    else if (nodeName.includes('Tordera')) {
      // Barcelona/Tordera - Nordeste, posici√≥n superior-izquierda
      positions[5].priority = 1; // top-left
      positions[0].priority = 2; // top
    }
    else if (nodeName.includes('Elche')) {
      // Alicante/Elche - Sureste, posici√≥n superior
      positions[0].priority = 1; // top
      positions[4].priority = 2; // top-right
    }
    else {
      // Para otros nodos, usar heur√≠stica basada en posici√≥n geogr√°fica
      console.log(`üéØ Posicionamiento autom√°tico para ${nodeName}`);
    }

    // Ordenar por prioridad y elegir la mejor posici√≥n
    positions.sort((a, b) => a.priority - b.priority);

    return positions[0];
  }

  // Funci√≥n para actualizar todas las posiciones de conectores
  function updateAllConnectors() {
    const svgContainer = document.getElementById('pin-connectors');
    const mapContainer = document.getElementById('spain-map');

    if (!svgContainer || !mapContainer) return;

    // Limpiar conectores existentes
    svgContainer.innerHTML = '';

    // Limpiar labels existentes
    const existingLabels = mapContainer.querySelectorAll('.pin-label-connected');
    existingLabels.forEach(label => label.remove());

    // Recrear conectores para todos los pins
    const pins = mapContainer.querySelectorAll('.region-center-pin[data-node-id]');
    pins.forEach(pin => {
      const nodeId = pin.getAttribute('data-node-id');
      const latency = pin.getAttribute('data-latency');
      const node = spainConfig.remoteNodes.find(n => n.id === nodeId);

      if (node && latency) {
        const latencyClass = getLatencyClass(parseInt(latency));
        setTimeout(() => {
          createPinConnector(node, pin as HTMLElement, latencyClass);
        }, 50);
      }
    });

    console.log('üîÑ Conectores actualizados');
  }

  // Funci√≥n para obtener estad√≠sticas b√°sicas del mapa
  function getSpainMapStats() {
    return {
      totalLocations: spainConfig.remoteNodes.length + 1, // +1 por Arteixo
      markersCount: markers.length,
      mapLoaded: map ? map.loaded() : false,
      isStatic: true
    };
  }

  // Inicializar cuando el DOM est√© listo
  document.addEventListener('DOMContentLoaded', initializeSpainMap);

  // Funciones globales para debugging
  (window as any).spainMapUtils = {
    getSpainConfig: () => spainConfig,
    getMap: () => map,
    getStats: getSpainMapStats,
    markers: () => markers,
    updateConnectors: updateAllConnectors,
    debugSpainMap: () => {
      console.log('=== DEBUG SPAIN MAP (STATIC) ===');
      console.log('Map loaded:', map ? map.loaded() : 'Not initialized');
      console.log('Total markers:', markers.length);
      console.log('Spain config locations:', spainConfig.remoteNodes.length);
      console.log('Central node:', spainConfig.centralNode);
      console.log('Connectors:', document.querySelectorAll('.pin-connector-line').length);
      console.log('Labels:', document.querySelectorAll('.pin-label-connected').length);
    },
    locationDetails: locationDetails
  };
</script>
